[[ch06]]
[[transactions]]
== Transacciones

[[ch06_intro]]
=== Introducción

((("transacciones", "definición")))((("advertencias y precauciones", see="también seguridad")))Las transacciones son la parte más importante del sistema bitcoin. Todo lo demás en bitcoin fue diseñado para asegurar que las transacciones puedan ser creadas, propagadas por la red, validadas y finalmente añadidas al libro de contabilidad global (la cadena de bloques). Las transacciones son estructuras de datos que codifican la transferencia de valor entre los participantes en el sistema bitcoin. Cada transacción es una entrada pública en la cadena de bloques de bitcoin, el libro de contabilidad global por partida doble.

En este capítulo examinaremos las varias formas de transacciones, qué contienen, cómo crearlas, cómo se verifican y cómo se vuelven parte del registro permanente de todas las transacciones. Cuando usemos el término "cartera" en este capítulo, nos referimos al software que construye las transacciones, no solo a las llaves de la base de datos.

[[tx_structure]]
=== Transacciones en Detalle

((("casos de uso", "comprando café", id="alicesix")))En <<ch02_bitcoin_overview>>, vimos la transacción que Alice usó para pagar el café en la cafetería de Bob usando un explorador de bloques (<<alices_transactions_to_bobs_cafe>>).

La aplicación del explorador de bloques muestra una transacción desde la "dirección" de Alice a la "dirección" de Bob. Esta es una vista mucho más simplificada de lo que contiene una transacción. De hecho, como veremos en este capítulo, gran parte de la información que se muestra está construida por el explorador de bloques y no está realmente en la transacción.

[[alices_transactions_to_bobs_cafe]]
.Transacción de Alice a la Cafetería de Bob
image::images/mbc2_0208.png["Transacción del Café de Alice"]

[[transactions_behind_the_scenes]]
==== Transacciones&#x2014;Detrás del Telón

((("transacciones", "detalles detrás del telón de las")))Detrás del telón, una transacción real se muestra muy diferente a una transacción proporcionada por un explorador de bloques típico. De hecho, la mayoría de las construcciones de alto nivel que vemos en las diversas interfaces de usuario de las aplicaciones de bitcoin _no existen realmente_ en el sistema bitcoin.

Podemos usar la interfaz de línea de comandos de Bitcoin Core (+getrawtransaction+ y +decoderawtransaction+) para recuperar la transacción "sin formato" de Alice, descodificarla y ver qué contiene. El resultado se ve así:

[[alice_tx]]
.La transacción de Alice decodificada
[source,json]
----
{
  "version": 1,
  "locktime": 0,
  "vin": [
    {
      "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
      "vout": 0,
      "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 0.01500000,
      "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"
    },
    {
      "value": 0.08450000,
      "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
    }
  ]
}
----

Puedes notar algunas cosas sobre esta transacción, ¡principalmente las cosas que faltan! ¿Dónde está la dirección de Alice? ¿Dónde está la dirección de Bob? ¿Dónde está la entrada 0.1 "enviada" por Alice? En bitcoin, no hay monedas, ni remitentes, ni destinatarios, ni saldos, ni cuentas, ni direcciones. Todas esas cosas se construyen en un nivel superior para beneficio del usuario, para que las cosas sean más fáciles de entender.

También puedes notar muchos campos extraños e indescifrables y cadenas hexadecimales. No te preocupes, explicaremos cada campo que se muestra aquí en detalle en este capítulo.

[[tx_inputs_outputs]]
=== Entradas y Salidas de una Transacción

((("transacciones", "salidas y entradas", id="Tout06")))((("salidas y entradas", "definición de salidas")))((("salidas de transacción sin gastar (UTXO)")))((("UTXO, sets")))((("transacciones", "salidas y entradas", "características de las salidas")))((("salidas y entradas", "características de las salidas")))El componente fundamental de una transacción bitcoin es una _salida de transacción_. Las salidas de transacción son fragmentos indivisibles de la moneda bitcoin, grabados en la cadena de bloques y reconocidos como válidos por toda la red. Los nodos completos de bitcoin realizan un seguimiento de todas las salidas disponibles y consumibles, conocidas como _salidas de transacción sin gastar_ o _UTXO_ (del inglés, Unspent Transaction Output). La colección de todos los UTXO se conoce como _set UTXO_ y actualmente asciende a millones de UTXO. El set UTXO crece a medida que se crea un nuevo UTXO y se reduce cuando se consume un UTXO. Cada transacción representa un cambio (una transición de estado) en el set UTXO.

((("saldos")))Cuando decimos que la cartera de un usuario ha "recibido" bitcoin, lo que queremos decir es que la cartera ha detectado una UTXO que se puede gastar con una de las llaves controladas por esa cartera. Por lo tanto, el "saldo" de bitcoin de un usuario es la suma de todas las UTXO que la cartera del usuario puede gastar y que pueden estar dispersas entre cientos de transacciones y cientos de bloques. El concepto de saldo es creado por la aplicación de la cartera. La cartera calcula el saldo del usuario escaneando la cadena de bloques y agregando el valor de cualquier UTXO que la cartera puede gastar con las llaves que controla. La mayoría de las carteras mantienen una base de datos o usan un servicio de base de datos para almacenar un set de referencia rápida de todas las UTXOs que pueden gastar con las llaves que controlan.

((("satoshis")))Una salida de transacción puede tener un valor arbitrario (entero) denominado como un múltiplo de satoshis. Así como los dólares se pueden dividir en dos decimales como centavos, bitcoin se puede dividir en ocho decimales como satoshis. Aunque una salida puede tener cualquier valor arbitrario, una vez creada, es indivisible. Esta es una característica importante de las salidas que se debe enfatizar: las salidas son unidades de valor _discreto_ e _indivisible_, denominadas en satoshis enteros. Una salida sin gastar solo puede ser consumida en su totalidad en una transacción.

((("cambio, creándolo")))Cuando un UTXO es mayor que el valor deseado de una transacción, se debe consumir en su totalidad y en la transacción se debe generar el cambio. En otras palabras, si tienes un UTXO con un valor de 20 bitcoin y quieres pagar solo 1 bitcoin, tu transacción debe consumir todo el UTXO de 20 bitcoin y producir dos salidas: una que paga 1 bitcoin al destinatario deseado y otra que paga 19 bitcoin en cambio de vuelta a tu cartera. Como las salidas de transacción son indivisibles, la mayoría de las transacciones bitcoin tendrán que generar cambio.

Imagina a un cliente que compra una bebida de $1.50, busca en su cartera y trata de encontrar una combinación de monedas y billetes para cubrir el costo de $1.50. El cliente elegirá la cantidad exacta si está disponible, por ejemplo. un billete de dólar y dos cuartos (un cuarto es $0.25), o una combinación de denominaciones más pequeñas (seis cuartos), o si es necesario, una unidad más grande, como un billete de $5. Si entrega demasiado dinero, digamos $5, al propietario de la tienda, esperará un cambio de $3.50, que retornará a su cartera y tendrá disponible para futuras transacciones.

Del mismo modo, una transacción bitcoin debe crearse desde el UTXO de un usuario en cualquiera de las denominaciones que ese usuario tenga disponible. Los usuarios no pueden cortar un UTXO a la mitad de la misma forma que no se puede cortar un billete de dólar a la mitad y usarlo como moneda. La aplicación de cartera del usuario normalmente seleccionará el UTXO disponible del usuario para componer una cantidad mayor o igual a la cantidad deseada de la transacción.

Al igual que en la vida real, una aplicación bitcoin puede usar varias estrategias para satisfacer el monto de la compra: combinar varias unidades más pequeñas, encontrar el cambio exacto, o usar una única unidad mayor al valor de la transacción y generar cambio. Todo este complejo montaje de UTXOs es calculado por la cartera del usuario automáticamente y es invisible al usuario. Solo es relevante si estás construyendo transacciones sin formato a partir de UTXOs programáticamente.

Una transacción consume salidas de transacciones no gastadas registradas previamente y crea nuevas salidas de transacciones que pueden ser consumidas por una transacción futura. De esta manera, los fragmentos de valor de bitcoin avanzan de un propietario a otro en una cadena de transacciones que consumen y crean UTXO.

((("transacciones", "transacciones coinbase")))((("transacciones coinbase")))((("minería y consenso", "transacciones coinbase")))La excepción a la cadena de salidas y entradas es un tipo especial de transacción llamada transacción _coinbase_, que es la primera transacción en cada bloque. Esta transacción es colocada allí por el minero "ganador" y crea bitcoin completamente nuevos que se pagan a ese minero como recompensa por la minería. Esta transacción coinbase especial no consume ninguna UTXO; en su lugar, tiene un tipo especial de entrada llamada "coinbase". Así es como se crea la oferta monetaria de bitcoin durante el proceso de minería, como veremos en <<mining>>.

[TIP]
====
¿Qué estuvo primero? ¿Entradas o salidas, el huevo o la gallina? Hablando en sentido estricto, las salidas están primero porque las transacciones coinbase, las cuales generan nuevos bitcoins, no poseen entradas y generan salidas de la nada.
====

[[tx_outs]]
==== Salidas de Transacción

((("transacciones", "salidas y entradas", "componentes de las salidas")))((("salidas y entradas", "partes de las salidas")))Cada transacción de bitcoin crea salidas, que se registran en el libro de contabilidad de bitcoin. Casi todas estas salidas, con una excepción (ver <<op_return>>) crean trozos de bitcoin que se pueden gastar llamados UTXO, que luego son reconocidos por toda la red y están disponibles para que el propietario los gaste en una transacción futura.

Cada cliente bitcoin de nodo completo hace un seguimiento del set UTXO. Las nuevas transacciones consumen (gastan) una o más de estas salidas del set UTXO.

Las salidas de una transacción consisten en dos partes:

* Una cantidad de bitcoins denominada en _satoshis_, la unidad más pequeña de bitcoin
* Un acertijo criptográfico que determina las condiciones necesarias para gastar la salida

((("scripts de bloqueo")))((("scripting", "scripts de bloqueo")))((("testigos")))((("scriptPubKey")))El acertijo criptográfico también se conoce como un script _de bloqueo_, un script _testigo_, o un +scriptPubKey+.

El lenguaje de script de transacción, utilizado en el script de bloqueo mencionado anteriormente, se describe en detalle en <<tx_script>>.

Ahora, veamos la transacción de Alice (que se mostró anteriormente en <<transactions_behind_the_scenes>>) y veamos si podemos identificar las salidas. En la codificación JSON, las salidas están en un array (lista) llamado +vout+:

[source,json]
----
"vout": [
  {
    "value": 0.01500000,
    "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY
    OP_CHECKSIG"
  },
  {
    "value": 0.08450000,
    "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
  }
]
----

Como puedes ver, la transacción contiene dos salidas. Cada salida está definida por un valor y un acertijo criptográfico. En la codificación mostrada por Bitcoin Core, el valor se muestra en bitcoin, pero en la transacción en sí se registra como un entero denominado en satoshis. La segunda parte de cada salida es el acertijo criptográfico que establece las condiciones para el gasto. Bitcoin Core muestra esto como +scriptPubKey+ y nos muestra una representación legible del script.

El asunto del bloqueo y desbloqueo de UTXO se tratará más adelante, en <<tx_lock_unlock>>. El lenguaje de script que se usa para el script en +scriptPubKey+ se describe en <<tx_script>>. Pero antes de profundizar en esos temas, debemos comprender la estructura general de las entradas y salidas de las transacciones.

===== Serialización de transacciones&#x2014;salidas

((("transacciones", "salidas y entradas", "estructura de")))((("salidas y entradas", "estructura de")))((("serialización", "salidas")))Cuando las transacciones se transmiten a través de la red o se intercambian entre aplicaciones, se _serializan_. La serialización es el proceso de convertir la representación interna de una estructura de datos en un formato que permite su transmisión un byte cada vez, también conocido como flujo de bytes. La serialización se usa más comúnmente para codificar estructuras de datos para la transmisión a través de una red o para el almacenamiento en un archivo. El formato de serialización de una salida de transacción se muestra en <<tx_out_structure>>.

[[tx_out_structure]]
.Serialización de salida de transacción
[opciones="título"]
|=======
|Tamaño| Campo | Descripción
| 8 bytes (little-endian) | Cantidad  | Valor bitcoin en satoshis (10^-8^ bitcoin)
| 1&#x2013;9 bytes (VarInt) | Tamaño Script de Bloqueo | Longitud Script de Bloqueo en bytes, a continuación
| Variable | Script de Bloqueo | Un script definiendo las condiciones necesarias para gastar la salida
|=======

La mayoría de las bibliotecas y los framework de bitcoin no almacenan transacciones internamente como flujos de bytes, ya que eso requeriría un análisis complejo cada vez que se necesite acceder a un solo campo. Por conveniencia y legibilidad, las bibliotecas de bitcoin almacenan transacciones internamente en estructuras de datos (generalmente estructuras orientadas a objetos).

((("deserialización")))((("parseo")))((("transacciones", "parseo")))El proceso de conversión desde la representación del flujo de bytes de una transacción a la representación de la estructura de datos interna de una biblioteca se denomina _deserialización_ o _parseo de la transacción_. El proceso de conversión inverso, como un flujo de bytes para la transmisión a través de la red, para el cálculo de hashes o para almacenamiento en disco, se denomina _serialización_. La mayoría de las bibliotecas de bitcoin tienen funciones integradas para la serialización y deserialización de transacciones.

Comprueba si puedes decodificar manualmente la transacción de Alice desde la forma hexadecimal serializada, localizando algunos de los elementos que vimos anteriormente. La sección que contiene las dos salidas se resalta en <<example_6_1>> para que sirva como ayuda:

[[example_6_1]]
.La transacción de Alice, serializada y presentada en notación hexadecimal
====
+0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73+
+4d2804fe65fa35779000000008b483045022100884d142d86652a3f47+
+ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039+
+ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813+
+01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84+
+16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1+
+7b4a10fa336a8d752adfffffffff02+*+60e31600000000001976a914ab6+*
*+8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000+*
*+1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac+*
+00000000+
====

Aquí tienes algunas pistas:

* Hay dos salidas en la sección resaltada, cada una serializada como se muestra en <<tx_out_structure>>.
* El valor de 0.015 bitcoin es 1,500,000 satoshis. Eso es +16 e3 60+ en hexadecimal.
* En la transacción serializada, el valor +16 e3 60+ se codifica en little-endian (el primer byte es el menos significativo), por lo que aparece como +60 e3 16+.
* La longitud del +scriptPubKey+ es 25 bytes, que es +19+ en hexadecimal.

[[tx_inputs]]
==== Entradas de Transacción

((("transacciones", "salidas y entradas", "componentes de las entradas")))((("salidas y entradas", "componentes de las entradas")))((("salidas de transacción sin gastar (UTXO)")))((("sets UTXO")))Las entradas de transacción identifican (por referencia) qué UTXO se consumirá y proporcionan prueba de propiedad a través de un script de desbloqueo.

Para crear una transacción, una cartera selecciona entre las UTXO que controla, un UTXO con el valor suficiente para realizar el pago solicitado. A veces, un UTXO es suficiente, otras veces se necesita más de uno. Para cada UTXO que se consumirá para realizar este pago, la cartera crea una entrada que apunta al UTXO y la desbloquea con un script de desbloqueo.

Veamos los componentes de una entrada con mayor detalle. La primera parte de una entrada es un puntero a un UTXO mediante la referencia al hash de transacción y un índice de salida, que identifican el UTXO específico en esa transacción. La segunda parte es un script de desbloqueo, que la cartera construye para satisfacer las condiciones de gasto establecidas en el UTXO. La mayoría de las veces, el script de desbloqueo es una firma digital y una llave pública que demuestra la propiedad del bitcoin. Sin embargo, no todos los scripts de desbloqueo contienen firmas. La tercera parte es un número de secuencia, que se discutirá más adelante.

Considera nuestro ejemplo en <<transactions_behind_the_scenes>>. Las entradas de transacción son un array (lista) llamado +vin+:

[[vin]]
.Las entradas de transacción en la transacción de Alice
[source,json]
----
"vin": [
  {
    "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
    "vout": 0,
    "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
    "sequence": 4294967295
  }
]
----

Como puedes ver, solo hay una entrada en la lista (porque un UTXO contenía suficiente valor para realizar este pago). La entrada contiene cuatro elementos:

* Un ((("IDs de transacción(txd)")))ID de transacción, que referencia a la transacción que contiene el UTXO que se está gastando
* Un índice de salida (+vout+), que identifica qué UTXO de esa transacción se está referenciando (la primera es cero)
* Un +scriptSig+, que satisface las condiciones impuestas en el UTXO, desbloqueándolo para gastar
* Un número de secuencia (que se explicará más adelante)

En la transacción de Alice, la entrada apunta al ID de transacción:

----
7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18
----

y al índice de la salida +0+ (es decir, el primer UTXO creado por esa transacción). La cartera de Alice construye el script de desbloqueo, recuperando primero el UTXO al que se hace referencia, examinando su script de bloqueo y luego usándolo para construir el script de desbloqueo correcto que lo satisface.

Observando solo la entrada, puedes haber notado que no sabemos nada acerca de este UTXO, aparte de una referencia a la transacción que lo contiene. No sabemos su valor (cantidad en satoshi), y no conocemos el script de bloqueo que establece las condiciones para gastarlo. Para encontrar esta información, debemos recuperar el UTXO al que se hace referencia recuperando la transacción subyacente. Ten en cuenta que debido a que el valor de la entrada no se establece explícitamente, también debemos utilizar el UTXO al que se hace referencia para calcular las comisiones que se pagarán en esta transacción (ver <<tx_fees>>).

No es solo la cartera de Alice la que necesita recuperar los UTXO a los que se hace referencia en las entradas. Una vez que esta transacción se transmite a la red, cada nodo de validación también deberá recuperar los UTXO a los que se hace referencia en las entradas de la transacción para validar la transacción.

Las transacciones por sí mismas parecen incompletas porque carecen de contexto. Hacen referencia a UTXO en sus entradas pero sin recuperar esas UTXO no podemos conocer el valor de las entradas o sus condiciones de bloqueo. Al escribir software de bitcoin, cada vez que decodifiques una transacción con la intención de validarla o contar las comisiones o verificar el script de desbloqueo, tu código primero tendrá que recuperar los UTXO referenciados de la cadena de bloques para construir el contexto implícito pero no presente en los UTXO referenciados por las entradas. Por ejemplo, para calcular la cantidad pagada en comisiones, debes conocer la suma de los valores de entradas y salidas. Pero sin recuperar los UTXO a los que se hace referencia en las entradas, no conoces sus valores. Por lo tanto, una operación aparentemente simple como el cálculo de comisiones en una sola transacción involucra múltiples pasos y datos de múltiples transacciones.

Con Bitcoin Core podemos usar la misma secuencia de comandos que usamos al recuperar la transacción de Alice (+getrawtransaction+ y +decoderawtransaction+). Con eso podemos obtener la referencia UTXO en la entrada anterior y echar un vistazo:

[[alice_input_tx]]
.El UTXO de Alice de la transacción anterior, referenciado en la entrada
[source,json]
----
"vout": [
   {
     "value": 0.10000000,
     "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG"
   }
 ]
----

Vemos que este UTXO tiene un valor de 0.1 BTC y que tiene un script de bloqueo (+scriptPubKey+) que contiene "OP_DUP OP_HASH160 ...".

[TIP]
====
Para comprender completamente la transacción de Alice, tuvimos que recuperar las transacciones anteriores a las que se hace referencia como entradas. Una función que recupera transacciones anteriores y salidas de transacciones no gastadas es muy común y existe en casi todas las bibliotecas y API de bitcoin.
====

===== Serialización de transacciones&#x2014;entradas

((("serialización", "entradas")))((("transacciones", "salidas y entradas", "serialización de entradas")))((("salidas y entradas", "serialización de entradas")))Cuando las transacciones se serializan para su transmisión en la red, sus entradas se codifican en un flujo de bytes como se muestra en <<tx_in_structure>>.

[[tx_in_structure]]
.Serialización de entradas de transacción
[opciones="título"]
|=======
|Tamaño| Campo | Descripción
| 32 bytes | Hash de Transacción | Puntero a la transacción que contiene el UTXO a ser gastado
| 4 bytes | Índice de Salida | El número de índice del UTXO a ser gastado; comenzando por 0
| 1&#x2013;9 bytes (VarInt) | Tamaño Script-de-Desbloqueo | Longitud del Script-de-Desbloqueo en bytes, a continuación
| Variable | Script-de-Desbloqueo | Un script que cumple las condiciones del script de bloqueo del UTXO
| 4 bytes | Número de Secuencia | Usado para locktime o deshabilitado (0xFFFFFFFF)
|=======

Al igual que con las salidas, veamos si podemos encontrar las entradas de la transacción de Alice en formato serializado. Primero, las entradas decodificadas:

[source,json]
----
"vin": [
  {
    "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
    "vout": 0,
    "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
    "sequence": 4294967295
  }
],
----

Ahora, veamos si podemos identificar estos campos en la codificación hexadecimal serializada en <<example_6_2>>:

[[example_6_2]]
.La transacción de Alice, serializada y presentada en notación hexadecimal
====
+0100000001+*+186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73+*
*+4d2804fe65fa35779000000008b483045022100884d142d86652a3f47+*
*+ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039+*
*+ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813+*
*+01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84+*
*+16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1+*
*+7b4a10fa336a8d752adfffffffff+*+0260e31600000000001976a914ab6+
+8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000+
+1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000+
+000+
====

Pistas:

* El ID de transacción se serializa en orden de bytes invertido, por lo que comienza con +18+ (hexadecimal) y termina con +79+
* El índice de la salida es un grupo de ceros de 4 bytes, fácil de identificar
* La longitud del +scriptSig+ es 139 bytes, o +8b+ en hexadecimal
* El número de secuencia se establece en +FFFFFFFF+, de nuevo fácil de identificar((("", startref="alicesix")))

[[tx_fees]]
==== Comisiones de Transacción

((("transacciones", "salidas y entradas", "comisiones de transacción")))((("comisiones", "transacción, comisiones")))((("minería y consenso", "recompensas y comisiones")))La mayoría de las transacciones incluyen comisiones de transacción, que compensan a los mineros de bitcoin por proteger la red. Las comisiones también sirven como un mecanismo de seguridad, al hacer que sea económicamente inviable que los atacantes inunden la red con transacciones. La minería y las comisiones y recompensas recolectadas por los mineros se discuten con más detalle en <<mining>>.

Esta sección examina cómo las comisiones de transacción son incluidas en una transacción típica. La mayoría de las carteras calculan e incluyen comisiones de transacción automáticamente. Sin embargo, si estás construyendo transacciones programáticamente o usando una interfaz de línea de comando, debes tenerlo en cuenta e incluir estas comisiones manualmente.

Las comisiones de transacción sirven de incentivo para incluir (minar) una transacción en el siguiente bloque y también como desincentivo contra el abuso del sistema al requerir un pequeño costo en cada transacción. Las comisiones de transacción son recolectadas por el minero que mina el bloque que registra la transacción en la cadena de bloques.

Las comisiones de transacción se calculan según el tamaño de la transacción en kilobytes, no según el valor de la transacción en bitcoins. En general las comisiones de transacción se establecen en base a fuerzas del mercado en la red bitcoin. Los mineros priorizan transacciones basándose en distintos criterios, incluyendo las comisiones y pueden hasta procesar transacciones sin comisión bajo ciertas circunstancias. Las comisiones de transacción afectan la prioridad de procesado, lo cual significa que una transacción con comisiones suficientes será muy probablemente incluida en el próximo bloque minado, mientras que una transacción con pocas comisiones o sin comisiones puede ser demorada, procesada cuando sea posible después de algunos bloques, o jamás procesada. Las comisiones de transacción no son obligatorias y las transacciones sin comisión pueden resultar finalmente procesadas; sin embargo, incluir comisiones en transacciones incentiva al procesado prioritario.

Con el tiempo, ha evolucionado la forma en que se calculan las comisiones de transacción y el efecto que tienen en la priorización de la transacción. Al principio, las comisiones de transacción eran fijas y constantes en toda la red. Gradualmente, la estructura de comisiones se relajó y puede verse influida por las fuerzas del mercado, según la capacidad de la red y el volumen de transacciones. Desde al menos a principios de 2016, los límites de capacidad en bitcoin han creado una competencia entre transacciones, lo que resulta en comisiones más altas y, de hecho, hace que las transacciones gratuitas sean cosa del pasado. Las transacciones de comisión cero o de comisión muy baja rara vez se minan y, a veces, ni siquiera se propagan a través de la red.

((("comisiones", "políticas de comisión de retransmisión")))((("opción minrelaytxfee")))En Bitcoin Core, las políticas de comisión de retransmisión se establecen mediante la opción +minrelaytxfee+. El valor actual predeterminado de +minrelaytxfee+ es 0.00001 bitcoin o una centésima de milibitcoin por kilobyte. Por lo tanto, de forma predeterminada, las transacciones con una comisión inferior a 0.00001 bitcoin se tratan como gratuitas y solo se retransmiten si hay espacio en el mempool; De lo contrario, se ignoran. Los nodos de Bitcoin pueden anular la política de comisión de retransmisión predeterminada ajustando el valor de +minrelaytxfee+.

((("comisiones dinámicas")))((("dinámicas", "comisiones")))Cualquier servicio de bitcoin que construya transacciones, incluidas carteras, intercambios, aplicaciones al por menor de comercio, etc., deben implementar comisiones dinámicas. Las comisiones dinámicas se pueden implementar a través de un servicio de terceros de estimación de comisiones o con un algoritmo de estimación de comisiones incorporado. Si no estás seguro, comienza con un servicio de terceros y a medida que adquieras experiencia, diseña e implementa tu propio algoritmo si deseas eliminar la dependencia de terceros .

Los algoritmos de estimación de comisiones calculan la comisión apropiada, según la capacidad y las comisiones que ofrecen las transacciones compitiendo entre ellas. Estos algoritmos van desde el simplista (comisión promedio o mediana en el último bloque) hasta sofisticado (análisis estadístico). Estiman la comisión necesaria (en satoshis por byte) que dará a una transacción una alta probabilidad de ser seleccionada e incluida dentro de un cierto número de bloques. La mayoría de los servicios ofrecen a los usuarios la opción de elegir comisiones de prioridad alta, media o baja. Alta prioridad significa que los usuarios pagan comisiones más altas, pero es probable que la transacción se incluya en el siguiente bloque. La prioridad media y baja significa que los usuarios pagan comisiones de transacción más bajas, pero las transacciones pueden tardar mucho más en confirmarse.

((("comisiones en bitcoin (servicio tercerizado)")))Muchas aplicaciones de cartera utilizan servicios tercerizados para el cálculo de las comisiones. Un servicio popular es https://bitcoinfees.earn.com/[_https://bitcoinfees.earn.com/_], que provee una API y un gráfico visual mostrando las comisiones en satoshis/byte para diversas prioridades.

[TIP]
====
((("comisiones estáticas")))((("comisiones", "comisiones estáticas")))Las comisiones estáticas ya no son viables en la red bitcoin. Las carteras que establecen comisiones estáticas producirán una experiencia de usuario deficiente ya que las transacciones a menudo se "atascarán" y no se confirmarán. Los usuarios que no entienden las transacciones y comisiones de bitcoin se sienten frustrados por las transacciones "atascadas" porque creen que han perdido su dinero.
====

El gráfico en <<bitcoinfeesearncom>> muestra la estimación de comisiones en tiempo real en incrementos de 10 satoshis/byte y el tiempo de confirmación esperado (en minutos y en número de bloques) para transacciones con comisiones en cada rango. Para cada rango de comisión (por ejemplo,  61&#x2013;70 satoshis/byte), dos barras horizontales muestran el número de transacciones no confirmadas (1405) y el número total de transacciones en las últimas 24 horas (102.975), con comisiones en ese rango. Según el gráfico, la comisión de alta prioridad recomendada en ese momento era de 80 satoshis/byte, una comisión que probablemente provocaría que la transacción fuese confirmada en el siguiente bloque (retraso nulo de bloques). Para una perspectiva, el tamaño medio de la transacción es de 226 bytes, por lo que la comisión recomendada por el tamaño de la transacción sería de 18.080 satoshis (0.00018080 BTC).

Los datos de estimación de comisiones se pueden recuperar a través de una simple HTTP REST API, en https://bitcoinfees.earn.com/api/v1/fees/recommended[https://bitcoinfees.earn.com/api/v1/fees/recommended]. Por ejemplo, en la línea de comando usando el comando +curl+:

.Usando la API de estimación de comisiones
----
$ curl https://bitcoinfees.earn.com/api/v1/fees/recommended

{"fastestFee":80,"halfHourFee":80,"hourFee":60}
----

El API devuelve un objeto JSON con la estimación de comisión actual para la confirmación más rápida (+fastFee+), confirmación dentro de tres bloques (+halfHourFee+) y seis bloques (+hourFee+), en satoshi por byte.

[[bitcoinfeesearncom]]
.Servicio de estimación de comisiones bitcoinfees.earn.com
image::images/mbc2_0602.png[Servicio de Estimación de Comisiones bitcoinfees.earn.com]

==== Añadiendo Comisiones a Transacciones

La estructura de datos de transacciones no posee un campo para comisiones. En cambio, las comisiones están implícitas como la diferencia entre la suma de las entradas y la suma de las salidas. Cualquier cantidad que sobre después de restar los valores de las entradas menos los de las salidas será la comisión recolectada por los mineros.

[[tx_fee_equation]]
.Las comisiones de transacción son implícitas como el excedente de entradas menos salidas:
----
Comisiones = Suma(Entradas) - Suma(Salidas)
----

Esto es un elemento un tanto confuso de las transacciones y un punto importante a entender, ya que si estás construyendo tus propias transacciones debes asegurarte de no incluir una comisión muy grande por descuido al gastar las entradas de menos. Esto significa que debes tener en cuenta todas las entradas, y si es necesario, crear una salida para el vuelto, ¡o terminarás dándole a los mineros una propina muy grande!

Por ejemplo, si consumes un UTXO de 20 bitcoin para hacer un pago de 1 bitcoin, debes incluir una salida adicional para un cambio de 19 bitcoin de regreso a tu cartera. De lo contrario, los 19 bitcoin "sobrantes" serán contados como la comisión de transacción y serán recolectados por el minero que mine tu transacción en un bloque. Aunque recibirás un procesado prioritario y harás muy feliz a un minero, esto probablemente no era lo que planeabas hacer.

[WARNING]
====
((("avisos y precauciones", "salidas de cambio")))Si te olvidas de añadir una salida de cambio en una transacción construida manualmente terminarás pagando el cambio como comisión de transacción. "¡Quédate el cambio!" puede no haber sido tu intención.
====

((("casos de uso", "comprando café")))Veamos cómo funciona esto en la práctica usando nuevamente como ejemplo la compra de café de Alice. Alice quiere gastar 0.015 bitcoins para pagar por un café. Para asegurar que esta transacción sea procesada rápidamente, ella querrá incluir una comisión de transacción, digamos de 0.001. Esto significará que el costo total de la transacción será de 0.016 bitcoins o más y, de ser necesario, creará una salida para el cambio. Digamos que su cartera tiene una UTXO de 0.2 bitcoins disponible. Por lo tanto necesitará consumir totalmente esta UTXO, crear una salida para el Café de Bob por 0.015, y una segunda salida con 0.184 bitcoin para el cambio, de regreso a su propia cartera, dejando 0.001 bitcoin sin asignar, lo cual será la comisión implícita para la transacción.

((("casos de uso", "donaciones de caridad")))((("donaciones de caridad")))Ahora veamos un caso diferente. Eugenia, nuestra directora de la beneficencia para niños en Filipinas ha completado una recaudación de fondos para adquirir libros para los niños. Ha recibido varios miles de pequeñas donaciones de personas de alrededor del mundo, las cuales suman 50 bitcoins, por lo que su cartera está llena de pagos muy pequeños (UTXO). Ahora ella quiere comprar cientos de libros escolares a una editorial local, pagando en bitcoin.

Ya que la aplicación de la cartera de Eugenia intenta construir una única gran transacción de pago, debe crearla a partir del set UTXO disponible, el cual está compuesto de múltiples montos más pequeños. Esto significa que la transacción resultante usará como fuente a más de cien UTXOs de pequeño valor como entradas y solo una salida, pagando a la editorial de libros. Una transacción con tantas entradas podrá ser más grande que un kilobyte, quizás de varios kilobytes en tamaño. Por lo tanto requerirá una comisión para la transacción mucho mayor que una transacción de tamaño mediano.

La aplicación de cartera de Eugenia calculará la comisión adecuada midiendo el tamaño de la transacción y multiplicándolo por el valor adecuado de comisión por kilobyte. Muchas carteras pagan comisiones más altas de lo necesario para transacciones muy grandes para asegurarse de que la transacción sea procesada rápidamente. La comisión elevada no es porque Eugenia esté gastando más dinero, sino porque su transacción es más compleja y más grande en tamaño--la comisión es independiente del valor en bitcoin de la transacción.((("", startref="Tout06")))

[[tx_script]]
[role="pagebreak-before less_space_h1"]
=== Scripts de Transacción y Lenguaje de Script

((("transacciones", "scripts y lenguaje de Script", id="Tsript06")))((("scripting", "transacciones y", id="Stransact06")))El lenguaje de script de las transacciones bitcoin, llamado _Script_, es un lenguaje basado en la ejecución en la pila con notación polaca inversa, similar a Forth. Si eso te suena como un trabalenguas, probablemente no habrás estudiado lenguajes de programación de la década de 1960, pero no hay de qué preocuparse&#x2014; lo explicaremos todo en este capítulo. Tanto el script de bloqueo colocado en una UTXO como el script de desbloqueo están escritos en este lenguaje de scripts. Cuando se valida una transacción, el script de desbloqueo en cada entrada se ejecuta junto con el script de bloqueo correspondiente para ver si satisface la condición de gasto.

Script es un lenguaje muy simple que fue diseñado para ser de alcance limitado y ejecutable en un amplio rango de hardware, tal vez tan simple como un dispositivo integrado. Requiere procesamiento mínimo y no puede hacer muchas de las cosas sofisticadas que los lenguajes modernos sí pueden. En el caso del dinero programable, esto es una medida deliberada de seguridad.

((("Pay-to-Public-Key-Hash (P2PKH)")))Hoy en día, la mayoría de las transacciones procesadas a través de la red bitcoin tienen el formato "Pago a la dirección bitcoin de Bob" y se basan en un script denominado Pay-to-Public-Key-Hash (es decir, Pagar-al-Hash-de-una-Llave-Pública). Sin embargo, las transacciones bitcoin no se limitan a la secuencia de comandos "Pago a la dirección bitcoin de Bob". De hecho, los scripts de bloqueo se pueden escribir para expresar una gran variedad de condiciones complejas. Para comprender estos scripts más complejos, primero debemos entender los conceptos básicos de los scripts de transacción y el lenguaje de script.

En esta sección, demostraremos los componentes básicos del lenguaje de script de las transacciones bitcoin y mostraremos cómo se pueden usar para expresar condiciones simples para gastar y cómo se pueden cumplir esas condiciones mediante el desbloqueo de scripts.

[TIP]
====
((("dinero programable")))La validación de transacciones bitcoin no se basa en un patrón estático, sino que se consigue a través de la ejecución de un lenguaje de scripts. Este lenguaje permite expresar una variedad casi infinita de condiciones. Así es cómo bitcoin adquiere el poder de "dinero programable".
====


==== Incompletitud de Turing

((("incompletitud de Turing")))El lenguaje de script de transacciones bitcoin contiene muchos operadores, pero se encuentra deliberadamente limitado en una forma importante—no tiene la capacidad de realizar bucles ni controles de flujo complejos más allá de los controles de flujo condicionales. Esto asegura que el lenguaje no es _Turing Completo_, lo cual significa que los scripts tienen complejidad limitada y tiempos de ejecución predecibles. El lenguaje script no es de propósito general. ((("ataques de denegación de servicio")))((("ataques de denegación de servicio", see="también seguridad")))((("seguridad", "ataques de denegación de servicio")))Estas limitaciones aseguran que el lenguaje no se pueda usar para crear un bucle infinito u otras formas de "bombas lógicas" que pudieran ser incrustadas en una transacción causando un ataque de denegación de servicio contra la red bitcoin. Recuérdese que cada transacción es validada por cada nodo completo en la red bitcoin. Un lenguaje limitado previene que el mecanismo de validación de transacciones pueda suponer una vulnerabilidad.

==== Verificación Sin Estado

((("verificación sin estado")))El lenguaje de script de transacciones bitcoin no tiene estados en el sentido de que no existe un estado previo a la ejecución del script, o un estado almacenado después de la ejecución del script. Por lo tanto, toda la información necesaria para ejecutar el script se encuentra contenida en el mismo script. Un script se ejecutará predeciblemente de la misma forma en cualquier sistema. Si tu sistema verifica un script, puedes estar seguro que cualquier otro sistema en la red bitcoin también verificará ese script, lo cual significa que una transacción es válida para todos y todos lo saben. Esta predictibilidad en los resultados es un beneficio esencial del sistema bitcoin.

[[tx_lock_unlock]]
==== Construcción de Scripts (Bloqueo + Desbloqueo)

El motor de validación de transacciones de bitcoin depende de dos tipos de scripts para validar transacciones: un script de bloqueo (locking script) y un script de desbloqueo (unlocking script) 

((("scripts de bloqueo")))((("scripts de desbloqueo")))((("scripts", "scripts de bloqueo")))Un script de bloqueo es una condición de gasto que se coloca en una salida: especifica las condiciones que deben cumplirse para gastar la salida en el futuro. ((("scriptPubKey")))Históricamente, el script de bloqueo se llamaba _scriptPubKey_, porque generalmente contenía una llave pública o una dirección bitcoin (el hash de esa llave pública). En este libro nos referimos a él como un "script de bloqueo" para reconocer el rango más amplio de posibilidades de esta tecnología del lenguaje script. En la mayoría de las aplicaciones de bitcoin, lo que llamamos un script de bloqueo aparecerá en el código fuente como +scriptPubKey+. ((("testigos")))((("acertijos criptográficos")))Encontrarás que al script de bloqueo también se le denomina _script testigo_ (en inglés, "witness script") (ver <<segwit>>) o más generalmente como _acertijo criptográfico_. Todos estos términos significan lo mismo, en diferentes niveles de abstracción.

Un script de desbloqueo es un script que "resuelve", o satisface, las condiciones puestas en una salida por un script de bloqueo y permite que la salida se gaste. Los scripts de desbloqueo forman parte de cada entrada de transacción. La mayoría de las veces contienen una firma digital producida por la cartera del usuario a partir de su llave privada. ((("scriptSig")))Históricamente, el script de desbloqueo se llamaba _scriptSig_, porque generalmente contenía una firma digital. En la mayoría de las aplicaciones de bitcoin, el código fuente se refiere al script de desbloqueo como +scriptSig+. También verás que al script de desbloqueo se le denomina _testigo_ (en inglés, "witness") (ver <<segwit>>). En este libro, nos referimos a él como un "script de desbloqueo" para reconocer el espectro mucho más amplio de requisitos de los scripts de bloqueo, ya que no todos los scripts de desbloqueo requieren firmas.

Cada nodo de validación de bitcoin validará las transacciones ejecutando a la vez los scripts de bloqueo y de desbloqueo. Cada entrada contiene un script de desbloqueo y se refiere a un UTXO preexistente. El software de validación copiará el script de desbloqueo, recuperará el UTXO al que hace referencia la entrada y copiará el script de bloqueo de ese UTXO. El script de desbloqueo y de bloqueo se ejecutan en secuencia. La entrada es válida si el script de desbloqueo cumple con las condiciones del script de bloqueo (ver <<script_exec>>). Todas las entradas se validan de forma independiente, como parte de la validación general de la transacción.

Ten en cuenta que la UTXO se registra permanentemente en la cadena de bloques, y por lo tanto es invariable y no se ve afectado por los intentos fallidos de gastarlo en una nueva transacción. Solo una transacción válida que satisfaga correctamente las condiciones de la salida hace que la salida se considere "gastada" y se elimine del set de salidas de transacción no gastadas (set UTXO).

<<scriptSig_and_scriptPubKey>> es un ejemplo de los scripts de desbloqueo y bloqueo para el tipo más común de transacción bitcoin (un pago a un hash de llave pública), mostrando el script combinado que resulta de la concatenación de los scripts de desbloqueo y de bloqueo previo a la validación del script.

[[scriptSig_and_scriptPubKey]]
.Combinando scriptSig y scriptPubKey para evaluar un script de transacción
image::images/mbc2_0603.png["scriptSig_y_scriptPubKey"]

===== La pila para la ejecución de scripts

El lenguaje de scripting de bitcoin es un lenguaje basado en la pila porque utiliza una estructura de datos llamada _pila_ (en inglés, "stack"). Una pila es una estructura de datos muy simple que se puede visualizar como una pila de cartas. Una pila permite dos operaciones: push (empujar) y pop (eliminar). Push agrega un elemento en la parte superior de la pila. Pop elimina el elemento superior de la pila. Las operaciones en una pila solo pueden actuar en el elemento superior de la pila. Una estructura de datos de pila también se llama una cola "LIFO" en la que el "último en entrar, es el primero en salir" (en inglés, Last-In-First-Out).

El lenguaje de script ejecuta el script procesando cada ítem de izquierda a derecha. Los números (valores de data constante) son empujados a la pila. Los operadores empujan o sacan uno o más parámetros de la pila, actúan sobre ellos, y pueden empujar un resultado a la pila. Por ejemplo, +OP_ADD+ sacará dos elementos de la pila, los sumará, y luego empujará la suma resultante a la pila.

Los operadores condicionales evalúan una condición, produciendo un resultado booleano de VERDADERO o FALSO. Por ejemplo, +OP_EQUAL+ saca dos elementos de la pila y empuja VERDADERO (VERDADERO es representado por el número 1) si son iguales y FALSO (representado por cero) si no son iguales. Los scripts de transacción bitcoin usualmente contienen un operador condicional, de forma que puedan producir el valor VERDADERO que significa que la transacción es válida.

===== Un script simple

Ahora apliquemos lo que hemos aprendido sobre scripts y pilas a algunos ejemplos simples.

En <<simplemath_script>>, el script +2 3 OP_ADD 5 OP_EQUAL+ muestra el operador de adición aritmética +OP_ADD+, el cual suma dos números y coloca el resultado en la pila, seguido por el operador condicional +OP_EQUAL+, el cual verifica que el resultado de la suma sea igual a +5+. Para ser concisos, el prefijo +OP_+ se omite en el ejemplo paso-a-paso. Para más detalles sobre los operadores y funciones disponibles en los scripts, ver <<tx_script_ops>>.

Aunque la mayoría de los scripts de bloqueo se refieren al  hash de una llave pública (esencialmente, una dirección bitcoin), y por lo tanto requieren una prueba de titularidad para gastar los fondos, el script no necesita ser tan complicado. Cualquier combinación de scripts de bloqueo y desbloqueo que resulte en VERDADERO será válido. La aritmética simple que usamos como ejemplo de lenguaje de script es también un script de bloqueo válido que puede usarse para bloquear una salida de transacción.

Usar parte del script del ejemplo aritmético como el script de bloqueo:

----
3 OP_ADD 5 OP_EQUAL
----

lo cual puede ser satisfecho por una transacción que contenga una entrada con el script de desbloqueo:

----
2
----

El software de validación combina los scripts de bloqueo y desbloqueo y el script resultante es:

----
2 3 OP_ADD 5 OP_EQUAL
----

Como vimos en el ejemplo paso-a-paso en <<simplemath_script>>, cuando se ejecuta el script, el resultado es +OP_TRUE+, haciendo a la transacción válida. No solo es esto un script de bloqueo de salida de transacción válido, sino que el UTXO resultante puede gastarse por cualquiera con la habilidad aritmética para saber que el número 2 satisface el script.

[TIP]
====
((("transacciones", "válidas e inválidas")))Las transacciones son válidas si el resultado en el tope de la pila es +VERDADERO+ (notado como ++&#x7b;0x01&#x7d;++), cualquier valor distinto de cero o si la pila se encuentra vacía luego de la ejecución del script. Las transacciones son inválidas si el valor en lo alto de la pila es +FALSO+ (un valor vacío de longitud cero, notado como ++&#x7b;&#x7d;++), o si la ejecución del script se detiene explícitamente por un operador, tal como +OP_VERIFY+, +OP_RETURN+, o un cierre de condicional como +OP_ENDIF+. Ver <<tx_script_ops>> para más detalles.
====

[[simplemath_script]]
.El script de validación de bitcoin haciendo matemática simple
image::images/mbc2_0604.png["TxScriptSimpleMathExample"]

[role="pagebreak-before"]
El siguiente es un script un poco más complejo, que calcula ++2 + 7 - 3 + 1 ++. Tenga en cuenta que cuando el script contiene varios operadores en una fila, la pila permite que el siguiente operador actúe sobre los resultados de un operador:

----
2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL
----

Intenta validar el script previo tú mismo usando papel y lápiz. Cuando la ejecución del script acabe, deberías terminar con el valor +VERDADERO+ en la pila.

[[script_exec]]
===== Ejecución por separado de los scripts de desbloqueo y de bloqueo

((("seguridad", "scripts de bloqueo y de desbloqueo")))En el cliente bitcoin original, los scripts de bloqueo y de desbloqueo se concatenaban y ejecutaban en secuencia. Por razones de seguridad esto se cambió en 2010, debido a una vulnerabilidad que permitía que un script de desbloqueo mal formado enviara datos a la pila y corrompiera el script de bloqueo. En la implementación actual los scripts se ejecutan de forma separada y la pila se transfiere entre las dos ejecuciones, como se describe a continuación.

Primero, se ejecuta el script de desbloqueo, utilizando el máquina de ejecución de la pila. Si la secuencia de comandos del script de desbloqueo se ejecuta sin errores (por ejemplo, no le quedan operadores "colgantes"), la pila principal se copia y se ejecuta la secuencia de comandos de bloqueo. Si el resultado de ejecutar el script de bloqueo con los datos de la pila copiados del script de desbloqueo es "VERDADERO", el script de desbloqueo ha logrado resolver las condiciones impuestas por el script de bloqueo y, por lo tanto, la entrada es una autorización válida para gastar la UTXO . Si después de la ejecución del script combinado permanece cualquier resultado que no sea "VERDADERO" , la entrada no es válida porque no ha cumplido con las condiciones de gasto colocadas en el UTXO.


[[p2pkh]]
==== Pagar-al-Hash-de-una-Llave-Pública (P2PKH)

((("pagar-al-hash-de-una-llave-pública (P2PKH, Pay-to-Public-Key-Hash)")))La gran mayoría de las transacciones procesadas en la red bitcoin gastan salidas bloqueadas por un script de pago-al-hash-de-una-llave-pública o "P2PKH". Estas salidas contienen un script de bloqueo que bloquea la salida para un hash de llave pública, más comúnmente conocida como una dirección bitcoin. Una salida bloqueada por un script P2PKH se puede desbloquear (gastar) presentando una llave pública y una firma digital creada por la llave privada correspondiente (ver <<digital_sigs>>).

((("casos de uso", "comprando café")))Por ejemplo, veamos nuevamente el pago de Alice al Café de Bob. Alice hizo un pago de 0.015 bitcoin a la dirección bitcoin del café. Esa salida de transacción tendría un script de bloqueo del tipo:

----
OP_DUP OP_HASH160 <Cafe Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG
----

El +Hash de Llave Pública del Café+ es equivalente a la dirección bitcoin del café, sin la codificación Base58Check. La mayoría de las aplicaciones mostrarían el _hash de llave pública_ en codificación hexadecimal y no el familiar formato Base58Check de la dirección bitcoin comenzado en "1."

El script de bloqueo anterior puede ser satisfecho con un script de desbloqueo de la forma:

----
<Cafe Signature><Cafe Public Key>
----

Los dos scripts juntos formarían el siguiente script de validación combinado:

----
<Cafe Signature> <Cafe Public Key> OP_DUP OP_HASH160
<Cafe Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG
----

Cuando es ejecutado, este script combinado será evaluado a VERDADERO si, y solo si, el script de desbloqueo cumple las condiciones establecidas por el script de bloqueo. En otras palabras, el resultado será VERDADERO si el script de desbloqueo contiene una firma válida proveniente de la llave privada del café que corresponde al hash de llave pública establecido como obstrucción.

Las figuras pass:[<a data-type="xref" href="#P2PubKHash1" data-xrefstyle="select: labelnumber">#P2PubKHash1</a>] y pass:[<a data-type="xref" href="#P2PubKHash2" data-xrefstyle="select: labelnumber">#P2PubKHash2</a>] muestran (en dos partes) una ejecución paso a paso del script combinado, que probará que esta es una transacción válida.((("", startref="Tsript06")))((("", startref="Stransact06")))

[[P2PubKHash1]]
.Evaluando un script de una transacción P2PKH (parte 1 de 2)
image::images/mbc2_0605.png["Tx_Script_P2PubKeyHash_1"]

[[P2PubKHash2]]
.Evaluando un script de una transacción P2PKH (parte 2 de 2)
image::images/mbc2_0606.png["Tx_Script_P2PubKeyHash_2"]

[[digital_sigs]]
=== Firmas Digitales (ECDSA)

((("transacciones", "firmas digitales y", id="Tdigsig06")))Hasta ahora, no hemos profundizado en ningún detalle sobre las "firmas digitales". En esta sección veremos cómo funcionan las firmas digitales y cómo pueden presentar una prueba de titularidad de una llave privada sin revelar esa llave privada.

((("firmas digitales", "algoritmo usado")))((("Algoritmo de Firma Digital de Curva Elíptica (ECDSA, Elliptic Curve Digital Signature Algorithm)")))El algoritmo de firma digital utilizado en bitcoin es el _Algoritmo de Firma Digital de Curva Elíptica_ (en inglés, Elliptic Curve Digital Signature Algorithm) o _ECDSA_. ECDSA es el algoritmo utilizado para firmas digitales basadas en pares de llaves privada/pública de curva elíptica, como se describe en <<elliptic_curve>>. Se usa ECDSA en las funciones de script +OP_CHECKSIG+, +OP_CHECKSIGVERIFY+, +OP_CHECKMULTISIG+, y +OP_CHECKMULTISIGVERIFY+. Cada vez que los veas en un script de bloqueo, el script de desbloqueo debe contener una firma ECDSA.

((("firmas digitales", "sus propósitos")))Una firma digital sirve para tres propósitos en bitcoin (consulta la siguiente barra lateral). Primero, la firma prueba que el propietario de la llave privada, quien es, en consecuencia, el propietario de los fondos, ha autorizado el gasto de esos fondos. En segundo lugar, constituye una prueba de autorización que es _innegable_ (no repudiable). En tercer lugar, la firma prueba que la transacción (o partes específicas de la misma) no ha sido modificada por nadie después de haber sido firmada.

Ten en cuenta que cada entrada de una transacción se firma de forma independiente. Esto es crítico, ya que ni las firmas ni las entradas tienen por qué pertenecer o firmarse por un mismo "propietario". De hecho, un esquema de transacción específico llamado "CoinJoin" usa este hecho para crear transacciones multipartitas con fines de privacidad.

[NOTE]
====
Cada entrada de transacción y cualquier firma que pueda contener es _completamente_ independiente de cualquier otra entrada o firma. Múltiples partes pueden colaborar para construir transacciones y firmar solo una entrada cada una.
====

[[digital_signature_definition]]
.Definición de "Firma Digital" en Wikipedia
****
((("firmas digitales", "definición")))Una firma digital es un esquema matemático para demostrar la autenticidad de un mensaje o documentos digitales. Una firma digital válida le da al destinatario razones para creer que el mensaje fue creado por un remitente conocido (autenticación), que el remitente no puede negar haber enviado el mensaje (no repudiable) y que el mensaje no se modificó en tránsito (integridad).

_Fuente: https://en.wikipedia.org/wiki/Digital_signature_
****

==== Cómo Funcionan las Firmas Digitales

((("firmas digitales", "cómo funcionan")))Una firma digital es un _esquema matemático_ que consta de dos partes. La primera parte es un algoritmo para crear una firma, utilizando una llave privada (la llave de la firma), y un mensaje (la transacción). La segunda parte es un algoritmo que permite a cualquier persona verificar la firma, dándose a conocer el mensaje y la correspondiente llave pública.

===== Creando una firma digital

En la implementación del algoritmo ECDSA de bitcoin, el "mensaje" que se firma es la transacción, o más precisamente un hash de un subconjunto específico de los datos de la transacción (ver <<sighash_types>>). La llave de la firma es la llave privada del usuario. El resultado es la firma:

latexmath:[\(Sig = F_{sig}(F_{hash}(m), dA)\)]

donde:

* _dA_ es la llave privada que firma
* _m_ es la transacción (o partes de ella)
* _F_~_hash_~ es la función hash empleada
* _F_~_sig_~ es el algoritmo de firma
* _Sig_ es la firma resultante

Puedes encontrar más detalles sobre las matemáticas de la ECDSA en <<ecdsa_math>>.

La función _F_~_sig_~ produce una firma +Sig+ que se compone de dos valores, referidos comúnmente como +R+ y +S+:

----
Sig = (R, S)
----

((("Reglas de Codificación Distinguidas (DER)")))Ahora que se han calculado los dos valores +R+ y +S+, se serializan en un hilo de bytes mediante un esquema de codificación estándar internacional llamado "Reglas de Codificación Distinguidas" o del inglés: _Distinguished Encoding Rules_, o _DER_.

[[seralization_of_signatures_der]]
===== Serialización de firmas (DER)

Veamos de nuevo la transacción que creó Alice((("casos de uso", "comprando café", id="alicesixtwo"))). En la entrada de la transacción hay un script de desbloqueo que contiene la siguiente firma codificada en DER desde la cartera de Alice:

----
3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301
----

Esa firma es un hilo de bytes serializado con los valores +R+ y +S+ producidos por la cartera de Alice para demostrar que posee la llave privada autorizada para gastar esa salida. El formato de serialización consta de nueve elementos como sigue:

* +0x30+&#x2014;indicando el principio de la secuencia DER
* +0x45+&#x2014;la longitud de la secuencia (69 bytes)
  * +0x02+&#x2014;sigue un valor entero
  * +0x21+&#x2014;la longitud del entero (33 bytes)
  * +R+&#x2014;++00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb++
  * +0x02+&#x2014;sigue otro entero
  * +0x20+&#x2014;la longitud del entero (32 bytes)
  * +S+&#x2014;++4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813++
* Un sufijo (+0x01+) indicando el tipo de hash usado (+SIGHASH_ALL+)

Prueba a ver si puedes decodificar la firma serializada de Alice (codificada en DER) usando esta lista. Los números importantes son +R+ y +S+; El resto de los datos son parte del esquema de codificación DER.

==== Verificando la Firma

((("firmas digitales", "verificando")))Para verificar la firma, debes tener la firma (+R+ y +S+), la transacción serializada y la llave pública (que corresponde a la llave privada utilizada para crear la firma). Esencialmente, la verificación de una firma significa "Sólo el propietario de la llave privada que generó esta llave pública podría haber producido esta firma en esta transacción".

El algoritmo de verificación de firma toma el mensaje (un hash de la transacción o partes de la misma), la llave pública del firmante y la firma (valores +R+ y +S+), y devuelve VERDADERO si la firma es válida para este mensaje y llave pública.

[[sighash_types]]
==== Tipos de Hash de Firma (SIGHASH)

((("firmas digitales", "tipos de hash de firmas")))((("compromiso")))Las firmas digitales se aplican a los mensajes, que en el caso de bitcoin, son las transacciones en sí mismas. La firma implica un _compromiso_ por parte del firmante con los datos específicos de la transacción. En la forma más simple, la firma se aplica a toda la transacción, confirmando así todas las entradas, salidas y otros campos de la transacción. Sin embargo, una firma puede comprometerse a solo un subconjunto de los datos de una transacción, lo cual es útil en varios escenarios como veremos en esta sección.

((("indicadores SIGHASH")))Las firmas de bitcoin tienen una forma de indicar qué parte de los datos de una transacción se incluyen en el hash firmado por la llave privada mediante un indicador +SIGHASH+. El indicador +SIGHASH+ es un byte único que se agrega a la firma. Todas las firmas tienen un indicador +SIGHASH+ y el indicador puede ser diferente de entrada a entrada. Una transacción con tres entradas firmadas puede tener tres firmas con diferentes indicadores +SIGHASH+, cada firma firmando (o comprometiendo) diferentes partes de la transacción.

Recuérdese, que cada entrada puede contener una firma con su propio script de desbloqueo. Como resultado, una transacción que contiene varias entradas puede tener firmas con diferentes indicadores +SIGHASH+ que comprometen diferentes partes de la transacción en cada una de las entradas. Téngase en cuenta también que las transacciones bitcoin pueden contener entradas de diferentes "propietarios", que pueden firmar solo una entrada en una transacción construida de manera parcial e inválida, colaborando con otros titulares para reunir todas las firmas necesarias para realizar una transacción válida. Muchos de los tipos de indicador +SIGHASH+ solo tienen sentido si se piensa en varios participantes que colaboran fuera de la red bitcoin y que actualizan una transacción parcialmente firmada.

[role="pagebreak-before"]
Existen tres indicadores +SIGHASH+: +ALL+, +NONE+, y +SINGLE+, como se muestra en <<sighash_types_and_their>>.

[[sighash_types_and_their]]
.Tipos SIGHASH y sus significados
[opciones="título"]
|=======================
|Indicador +SIGHASH+| Valor | Descripción
| +ALL+ | 0x01 | Firma que se aplica a todas las entradas y todas las salidas
| +NONE+ | 0x02 | Firma aplicada a todas las entradas, pero no toma en cuenta a ninguna de las salidas
| +SINGLE+ | 0x03 | Firma aplicada a todas las entradas pero solo toma en cuenta a aquella salida con el mismo número de índice que la entrada firmada
|=======================

Además, hay un indicador modificador +SIGHASH_ANYONECANPAY+, que se puede combinar con cada uno de los indicadores anteriores. Cuando se establece +ANYONECANPAY+, solo se firma una entrada, dejando el resto (y sus números de secuencia) abiertos para su modificación. El +ANYONECANPAY+ tiene el valor +0x80+ y se aplica mediante OR en modo bit, lo que da como resultado los indicadores combinados como se muestran en <<sighash_types_with_modifiers>>.

[[sighash_types_with_modifiers]]
.Tipos SIGHASH con modificadores y sus significados
[opciones="título"]
|=======================
|Indicador SIGHASH| Valor | Descripción
| ALL\|ANYONECANPAY | 0x81 | Firma aplica a una sola entrada pero para todas las salidas
| NONE\|ANYONECANPAY | 0x82 | Firma aplica a una sola entrada, sin tomar en cuenta a ninguna de las salidas
| SINGLE\|ANYONECANPAY | 0x83 | Firma aplica a una sola entrada y sólo a la salida con el mismo número de índice que la entrada que esta firmando
|=======================

Estas combinaciones de indicadores se resumen en <<sighash_combinations>>.

[[sighash_combinations]]
.Resumen de diferentes combinaciones de indicadores sighash
image::images/sighash_combinations.png["Resumen de diferentes combinaciones de indicadores SIGHASH"]

La forma en que se aplican los indicadores +SIGHASH+ durante la firma y su verificación es realizando una copia de la transacción y truncando ciertos campos de ésta (se establece la longitud a cero y se vacía). La transacción resultante es serializada. El indicador +SIGHASH+ se agrega al final de la transacción serializada y se calcula el valor hash a este resultado. El hash en sí es el "mensaje" que se está firmado. Dependiendo del indicador +SIGHASH+ que se use, se truncarán diferentes partes de la transacción. El hash resultante depende de los diferentes subconjuntos de los datos de la transacción. Al incluir el +SIGHASH+ como último paso antes del hash, la firma también confirma el tipo +SIGHASH+, por lo que no puede cambiarse (por ejemplo, por un minero) .

[NOTE]
====
Todos los tipos +SIGHASH+ firman el campo +nLocktime+ de la transacción  (ver <<transaction_locktime_nlocktime>>). Además, el tipo +SIGHASH+ en sí mismo se añade a la transacción antes de que ésta se firme, por lo que no se puede modificar una vez que se haya firmado.
====

En el ejemplo de la transacción de Alice (ver la lista en <<seralization_of_signatures_der>>), vimos que la última parte de la firma codificada en DER era +01+, que es el indicador +SIGHASH_ALL+. Esto bloquea los datos de la transacción, por lo que la firma de Alice está confirmando el estado de todas las entradas y salidas. Este es la forma de firma más común.

Veamos otros tipos de +SIGHASH+ y cómo se pueden usar en la práctica:

+ALL|ANYONECANPAY+ :: ((("donaciones caritativas")))((("casos de uso", "donaciones caritativas")))Esta construcción se puede usar para realizar una transacción de tipo "crowdfunding&#x201d;. Alguien que intente recaudar fondos puede construir una transacción con una sola salida. La única salida paga la cantidad "objetivo" al recaudador de fondos. Semejante transacción obviamente no es válida, ya que no tiene las suficientes entradas. Sin embargo, otras personas ahora pueden modificarla agregando entradas propias, como donación. Firman su propia entrada con +ALL|ANYONECANPAY+. A menos que se recopilen suficientes entradas para alcanzar el valor de la salida, la transacción no es válida. Cada donación es una "promesa", que no puede ser reclamada por el recaudador de fondos hasta que no se acumule la cantidad objetivo total.

+NONE+ :: Esta construcción se puede usar para crear un "cheque al portador" o "cheque en blanco" de una cantidad específica. Se compromete con la entrada, pero permite cambiar el script de bloqueo de salida. Cualquiera puede escribir su propia dirección bitcoin en el script de bloqueo de salida y gastar la transacción. Sin embargo, el valor mismo de la salida estará bloqueado por la firma.

+NONE|ANYONECANPAY+ :: Esta construcción se puede usar para ensamblar un "colector de polvo". Los usuarios que tienen diminutas UTXOs en sus billeteras no pueden gastarlas sin que el costo en las comisiones sea superior al valor del polvo. Con este tipo de firma, el polvo UTXO puede ser donado para que cualquiera lo agregue y lo gaste cuando lo desee.

((("Bitmask Sighash Modes")))Hay algunas propuestas para modificar o expandir el sistema +SIGHASH+. Una de estas propuestas es _Bitmask Sighash Modes_ de Glenn Willen de Blockstream, como parte del proyecto Elements. Esto apunta a crear un reemplazo flexible para los tipos +SIGHASH+ que permite "máscaras de bits de entradas y salidas arbitrarias y reescribibles por minería" que pueden expresar "esquemas de compromiso contractual más complejos, como ofertas firmadas con cambio en un intercambio de activos distribuidos".

[NOTE]
====
Nadie verá los indicadores +SIGHASH+ presentados como opción en la aplicación de cartera de un usuario. Con pocas excepciones, las carteras construyen sus scripts P2PKH y firman con los indicadores +SIGHASH_ALL+. Para usar un indicador +SIGHASH+ diferente, tendríamos que escribir un software especial para construir y firmar transacciones. Más importante aún, los indicadores +SIGHASH+ pueden ser utilizados por aplicaciones de bitcoin para propósitos especiales que permiten usos novedosos.
====

[[ecdsa_math]]
==== Matemáticas ECDSA

((("Algoritmo de Firma Digital de Curva Elíptica (ECDSA)")))Como se mencionó anteriormente, las firmas se crean mediante una función matemática _F_~_sig_~ que produce una firma compuesta por dos valores _R_ y _S_. En esta sección veremos la función _F_~_sig_~ con más detalle.

((("llaves privadas y públicas", "par de llaves", "fugacidad")))El algoritmo de firma genera primero un par de llaves público-privadas _fugaces_ (temporales). Este par de llaves temporales se usan en el cálculo de los valores _R_ y _S_, después de una transformación que involucra la llave privada de la firma y el hash de transacción.

El par de llaves temporales se basan en un número aleatorio _k_, que se utiliza como llave privada temporal. Desde _k_, generamos la correspondiente llave pública temporal _P_ (calculada como _P = k*G_, de la misma manera en que se derivan las llaves públicas de bitcoin; ver <<pubkey>>). El valor _R_ de la firma digital es entonces la coordenada x de la llave pública efímera _P_.

A partir de ahí, el algoritmo calcula el valor _S_ de la firma, de manera que:

_S_ = __k__^-1^ (__Hash__(__m__) + __dA__ * __R__) _mod n_

donde:

* _k_ es la llave privada efímera
* _R_ es la coordenada x de la llave pública efímera
* _dA_ es la llave privada que firma
* _m_ son los datos de la transacción
* _n_ es el orden de núero primo de la curva elíptica

La verificación es la inversa de la función de generación de firmas, utilizando los valores _R_, _S_ y la llave pública para calcular un valor _P_, que es un punto en la curva elíptica (la llave pública efímera utilizada en la creación de la firma):

_P_ = __S__^-1^ * __Hash__(__m__) * _G_ + __S__^-1^ * _R_ * _Qa_

donde:

* _R_ y _S_ son los valores de la firma
* _Qa_ es la llave pública de Alice
* _m_ son los datos de la transacción que ha sido firmada
* _G_ es el punto generador de la curva elíptica

Si la coordenada x del punto calculado _P_ es igual a _R_, entonces el verificador puede concluir que la firma es válida.

Téngase en cuenta que al verificar la firma, la llave privada no se conoce ni se revela.

[TIP]
====
ECDSA es necesariamente una parte bastante complicada de las matemáticas; Una explicación completa está fuera del alcance de este libro. Una serie de excelentes guías en línea pueden orientar al lector paso a paso: búsquese "ECDSA explained" o consúltese: http://bit.ly/2r0HhGB[].
====

==== La Importancia de la Aleatoriedad en las Firmas

((("firmas digitales", "aleatoriedad en ellas")))Como vimos en <<ecdsa_math>>, el algoritmo de generación de firmas utiliza una llave aleatoria _k_, como base para generar un par de llaves público/privada efímeras. El valor de _k_ no es importante, _siempre que sea aleatorio_. Si se usa el mismo valor _k_ para producir dos firmas con diferentes mensajes (transacciones), entonces la _llave privada_ firmante podría ser calculada por cualquier persona. ¡La reutilización del mismo valor para _k_ en un algoritmo de firma conduce a la exposición de la llave privada!

[WARNING]
====
((("advertencias y precauciones", "firmas digitales")))Si se usa el mismo valor _k_ en el algoritmo de firma en dos transacciones diferentes, ¡la llave privada se puede calcular y puede quedar expuesta al mundo!
====

Esto no es solo una posibilidad teórica. Hemos visto que este problema lleva a exponer las llaves privadas en algunas implementaciones diferentes de algoritmos de firma de transacciones en bitcoin. Se han robado fondos debido a la reutilización involuntaria de un valor _k_. La razón más común para la reutilización de un valor _k_ es un generador de números aleatorios incorrectamente inicializado.

((("números aleatorios", "generación de números aleatorios")))((("entropía", "generación de números aleatorios")))((("inicialización determinista")))Para evitar esta vulnerabilidad, la mejor práctica de la industria es no generar _k_ con un generador de números aleatorios inicializados con entropía, sino usar un proceso aleatorio determinista inicializado con los datos de la transacción en sí. Esto asegura que cada transacción produce un _k_ diferente. El algoritmo estándar de la industria para la inicialización determinista de _k_ se define en https://tools.ietf.org/html/rfc6979[RFC 6979], publicado por Internet Engineering Task Force.

Si estás implementando un algoritmo para firmar transacciones en bitcoin, debes usar RFC 6979 o un algoritmo aleatorio determinista similar para asegurarte de generar un _k_ diferente para cada transacción.((("", startref="Tdigsig06")))

=== Direcciones Bitcoin, Saldos y Otras Abstracciones

((("transacciones", "abstracciones de alto nivel", id="Thigher06")))Comenzaremos este capítulo con el descubrimiento de que las transacciones se ven muy diferentes "detrás del telón" en comparación con la forma en que se presentan en carteras, exploradores de la cadena de bloques y otras aplicaciones orientadas al usuario. Muchos de los conceptos simplistas y familiares de los capítulos anteriores, como las direcciones y saldos de bitcoin, parecen estar ausentes de la estructura de una transacción. Vimos que las transacciones no contienen direcciones bitcoin, de por sí, sino que operan a través de scripts que bloquean y desbloquean valores discretos de bitcoin. Los saldos no están presentes en ninguna parte de este sistema y, sin embargo, cada aplicación de cartera muestra de manera destacada el saldo de la cartera del usuario.

Ahora que hemos explorado lo que realmente se incluye en una transacción bitcoin, podemos examinar cómo las abstracciones de alto nivel se derivan de los componentes aparentemente primitivos de la transacción.

Veamos de nuevo cómo la transacción de Alice se presentó en un explorador de bloques popular (<<alice_transaction_to_bobs_cafe>>).

[[alice_transaction_to_bobs_cafe]]
.Transacción de Alice a la Cafetería de Bob
image::images/mbc2_0208.png["Transacción del Café de Alice"]

En el lado izquierdo de la transacción, el explorador de la cadena de bloques muestra la dirección bitcoin de Alice como el "remitente". De hecho, esta información no está en la transacción en sí. Cuando el explorador de la cadena de bloques hace referencia a la transacción, también hace referencia a la transacción anterior asociada con la entrada y extrae la primera salida de esa transacción anterior. Dentro de esa salida hay un script de bloqueo que bloquea la UTXO al hash de la llave pública de Alice (un script P2PKH). El explorador de la cadena de bloques extrajo el hash de la llave pública y lo codificó utilizando la codificación Base58Check para producir y mostrar la dirección bitcoin que representa esa llave pública.

De manera similar, en el lado derecho, el explorador de la cadena de bloques muestra las dos salidas; la primera a la dirección bitcoin de Bob y la segunda a la dirección bitcoin de Alice (como cambio). Una vez más, para crear estas direcciones bitcoin, el explorador de la cadena de bloques extrajo el script de bloqueo de cada salida, lo reconoció como un script P2PKH y extrajo el hash de llave pública desde dentro. Finalmente, el explorador de la cadena de bloques recodificó ese hash de llave pública con el estándar Base58Check para producir y mostrar las direcciones bitcoin.

Si hicieras clic en la dirección bitcoin de Bob, el explorador de la cadena de bloques te mostraría la imagen en <<the_balance_of_bobs_bitcoin_address>>.

[[the_balance_of_bobs_bitcoin_address]]
.El saldo de la dirección bitcoin de Bob
image::images/mbc2_0608.png["El saldo de la dirección bitcoin de Bob"]

El explorador de la cadena de bloques muestra el saldo de la dirección bitcoin de Bob. Pero en ninguna parte del sistema de bitcoin hay un concepto de "saldo". Más bien, los valores que se muestran aquí son construidos por el explorador de la cadena de bloques de la siguiente manera.

Para construir la cantidad "Total recibida", el explorador de la cadena de bloques primero decodificará la codificación Base58Check de la dirección bitcoin para recuperar el hash de 160 bits de la llave pública de Bob que está codificada dentro de la dirección. Después, el explorador de la cadena de bloques buscará en la base de datos de transacciones, intentando hallar resultados con scripts de bloqueo P2PKH que contengan el hash de llave pública de Bob. Al sumar el valor de todas las salidas, el explorador de la cadena de bloques puede mostrar el valor total recibido.

La construcción del saldo actual (que se muestra como "Saldo Final") requiere un poco más de trabajo. El explorador de la cadena de bloques mantiene una base de datos de las salidas que actualmente no se han gastado; el set UTXO. Para mantener esta base de datos, el explorador de la cadena de bloques debe monitorizar la red bitcoin, agregar las UTXOs recién creadas y eliminar las UTXOs gastadas, en tiempo real, tal como aparecen en las transacciones no confirmadas. Este es un proceso complicado que requiere realizar un seguimiento de las transacciones a medida que se propagan, así como mantener el consenso con la red bitcoin para garantizar que se siga a la cadena correcta. A veces, el explorador de la cadena de bloques se desincroniza y su visión del set UTXO es incompleta o incorrecta.

A partir del set UTXO, el explorador de la cadena de bloques suma el valor de todas las salidas sin gastar que hacen referencia al hash de la llave pública de Bob y produce el número de "Saldo Final" que se muestra al usuario.

Para producir esta imagen, con estos dos "saldos", el explorador de la cadena de bloques debe indexar y buscar entre docenas, cientos o incluso cientos de miles de transacciones.

En resumen, la información presentada a los usuarios a través de las aplicaciones de billetera, exploradores de la cadena de bloques y otras interfaces de usuario de bitcoin, a menudo se componen de abstracciones de nivel superior que se obtienen al buscar muchas transacciones diferentes, inspeccionar sus contenidos y manipular los datos ubicados en ellas. Al presentar esta visión simplista de las transacciones de bitcoin que se parecen a los cheques bancarios de un remitente a un destinatario, estas aplicaciones deben abstraer muchos detalles subyacentes. Se centran principalmente en los tipos comunes de transacciones: P2PKH con firmas SIGHASH_ALL en cada entrada. Por lo tanto, si bien las aplicaciones de bitcoin pueden exhibir a más del 80% de todas las transacciones de una manera fácil de leer, a veces se ven confundidas por transacciones que se desvían de la norma. Las transacciones que contienen scripts de bloqueo más complejos, o diferentes indicadores SIGHASH, o muchas entradas y salidas, demuestran la simplicidad y debilidad de estas abstracciones.

Todos los días, cientos de transacciones que no contienen salidas P2PKH se confirman en la cadena de bloques. Los exploradores de cadena de bloques a menudo presentan estos con mensajes de advertencia en rojo, que dicen que no pueden decodificar ninguna dirección.

Como veremos en el siguiente capítulo, estas no son necesariamente transacciones extrañas. Son transacciones que contienen scripts de bloqueo más complejos que los P2PKH comunes. Aprenderemos cómo descifrar y comprender scripts más complejos y las aplicaciones que las admiten a continuación.((("", startref="Thigher06")))((("", startref="alicesixtwo")))