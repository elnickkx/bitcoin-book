[[ch04_keys_addresses]]
== Kulcsok, címek

((("kriptográfia", "definíciója")))((("kriptográfia", see="also kulcsok és címek")))Talán hallott már róla, hogy a bitcoin _kriptográfián_ alapul, ami a matematika egy ága, amit elterjedten használnak a számítógépes biztonság területén. A kriptográfia görögül "titkosírást" jelent, de a kriptográfia tudománya a titkosírásnál, vagyis titkosításnál többet ölel fel. A kriptográfia arra is használható, hogy egy titok ismeretét annak felfedése nélkül bizonyítsuk (digitális aláírás), vagy egy adat hitelességet bizonyítsuk (digitális ujjlenyomat). Ezek a kriptográfiai bizonyítások a bitcoin számára nélkülözhetetlen matematikai eszközök, és használatuk elterjedt a bitcoin alkalmazásokban. ((("titkosítás")))((("titkosítás", see="also kulcsok és címek")))Maga a titkosítás nem fontos része a bitcoinnak, mivel a kommunikáció és tranzakciós adatok nincsenek titkosítva, és ez nem is szükséges a pénz védelméhez. Ebben a fejezetben bemutatjuk a bitcoinban használt kriptográfia egy részét, ami kulcsok, címek és pénztárcák formájában a tulajdonjog igazolását szolgálja.

=== Bevezetés

((("digitális kulcsok", see="kulcsok és címek")))((("kulcsok és címek", "áttekintése", id="KAover04")))((("digitális aláírások", "célja")))A bitcoinban a tulajdonjogot a _digitális kulcsok_, a _bitcoin címek_ és a _digitális aláírások_ teremtik meg. A digitális kulcsokat nem a hálózat tárolja, hanem a végfelhasználók hozzák létre és tárolják őket – vagy egy állományban vagy egy egyszerű adatbázisban, melynek _pénztárca_ a neve. A felhasználó pénztárcájában lévő digitális kulcsok teljesen függetlenek a bitcoin protokolltól, a kulcsok a felhasználó pénztárca szoftverével a blokkláncra történő hivatkozás vagy internet hozzáférés nélkül állíthatók elő és kezelhetők. A kulcsok valósítják meg a bitcoin sok érdekes tulajdonságát, többek között a decentralizált bizalmat és felügyeletet, a tulajdonjog igazolását és a kriptográfiailag helyes biztonsági modellt.

A legtöbb bitcoin tranzakciónak érvényes aláírással kell rendelkeznie, csak ekkor lesz befoglalva a blokkláncba. Az aláírások viszont csak érvényes digitális kulcsokkal állíthatók elő, ezért ha valaki rendelkezik ezekkel a kulcsokkal, akkor rendelkezik ezekkel a bitcoinokkal is. ((("tanúk")))A pénz elköltéséhez használt digitális aláírást _tanúnak_ is nevezzük, ami egy kriptográfiai kifejezés. Egy bitcoin tranzakcióban lévő tanúk az elköltött pénz valódi tulajdonjogáról tanúskodnak.

((("nyilvános és titkos kulcsok", "kulcspárok")))((("nyilvános és titkos kulcsok", see="kulcsok és címek")))A kulcsok párokból állnak, az egyik a titkos (privát) kulcs, a másik a nyilvános kulcs. A nyilvános kulcsra gondoljanak úgy, mint egy bankszámla számra, a titkos kulcsra pedig úgy, mint egy titkos PIN kódra, vagy egy csekken lévő aláírásra, amely megteremti a számla feletti felügyeletet. Ezeket a digitális kulcsokat a bitcoin felhasználók ritkán látják. Többnyire a pénztárca állományban vannak tárolva, és a pénztárca szoftver kezeli őket.

A bitcoin tranzakciók kifizetésekhez tartozó részében a címzett nyilvános kulcsát egy _bitcoin címnek_ nevezett digitális ujjlenyomat képviseli, amelynek ugyanaz a szerepe, mint egy csekken a kedvezményezett nevének. A legtöbb esetben a bitcoin cím egy nyilvános kulcsból jön létre, és megfelel a nyilvános kulcsnak. De nem minden bitcoin cím felel meg egy nyilvános kulcsnak, a címek más kedvezményezetteket, pl. scripteket is képviselhetnek, amint azt a fejezet későbbi részében látni fogjuk. Ily módon a bitcoin címek a pénzösszeg címzettjeit személyesítik meg, és a papír alapú csekkekhez hasonlóan a tranzakciókat rugalmassá teszik: ugyanaz a fizetési eszköz használható magánszemélyek vagy cégek számláinál, be- vagy kifizetésre. A bitcoin cím a kulcsok egyetlen olyan megjelenési formája, amivel a felhasználók rendszeresen találkoznak, mivel ezt kell megosztaniuk a nagyvilággal.

Először, bemutatjuk a kriptográfiát, és elmagyarázzuk a bitcoinban alkalmazott matematikát. Ezután megvizsgáljuk, hogyan történik a kulcsok létrehozása, tárolása és kezelése. Áttekintjük a különféle kódolási formátumokat, melyek a titkos és nyilvános kulcsok, címek és script címek ábrázolására szolgálnak. Végül a kulcsok és címek haladóbb felhasználásait tekintjük át, melyek a következők: kérkedő címek (vanity address), multisignature és script címek és papír alapú pénztárcák.

==== A nyilvános kulcsú titkosítás és a digitális pénz

((("kulcsok és címek", "áttekintése", "nyilvános kulcsú titkosítás")))((("digitális pénz", "kriptopénz")))A nyilvános kulcsú titkosítást az 1970-es években találták fel. A számítógép- és információbiztonság matematikai alapjait a nyilvános kulcsú titkosítás képzi.

A nyilvános kulcsú titkosítás felfedezése óta számos, e célra alkalmas matematikai függvényt fedeztek fel, pl. a prímszámok hatványozását vagy az elliptikus görbéken történő szorzást. Ezek a matematikai függvények gyakorlatilag megfordíthatatlanok, ami azt jelenti, hogy könnyű őket az egyik irányban kiszámítani, de ez a másik irányban gyakorlatilag lehetetlen. A titkosítás ezekre a matematikai függvényekre épül, és lehetővé teszi a digitális titkok és a nem hamisítható digitális aláírások létrehozását. A bitcoin elliptikus görbén történő szorzást használ titkosításra.

A bitcoinnál nyilvános kulcsú titkosítást használunk egy olyan kulcspár létrehozására, amely a bitcoinhoz történő hozzáférést szabályozza. A kulcspár egy titkos kulcsból és a belőle származó egyedi nyilvános kulcsból áll. A nyilvános kulcs szolgál pénz fogadására, a titkos kulcs szolgál a tranzakciók aláírására és a pénz elköltésére.

There is a mathematical relationship between the public and the private key that allows the private key to be used to generate signatures on messages. These signatures can be validated against the public key without revealing the private key.

Ha egy bitcoin tulajdonos el akarja költeni a bitcoinját, akkor egy tranzakcióban bemutatja a nyilvános kulcsát és egy aláírást (ami minden egyes alkalommal különböző, de ugyanabból a titkos kulcsból áll elő). A nyilvános kulcs és az aláírás révén a bitcoin hálózat bármelyik tagja ellenőrizni tudja a tranzakciót, meg tudja állapítani, hogy érvényes-e, és meg tud bizonyosodni arról, hogy a bitcoint küldő személy valóban birtokolta-e őket a küldés idején.

[TIP]
====
((("kulcsok és címek", "áttekintése", "kulcspárok")))A legtöbb megvalósítás a titkos és nyilvános kulcsokat az egyszerűség kedvéért együtt, egy _kulcspárként_ tárolja. Mivel a nyilvános kulcs előállítása a titkos kulcs ismeretében triviális feladat, ezért az is előfordulhat, hogy a pénztárcában csupán a titkos kulcs van tárolva.
====

[[private_public_keys]]
==== Titkos és nyilvános kulcsok

((("kulcsok és címek", "áttekintése", "titkos és nyilvános kulcspárok")))((("elliptikus görbékre épülő kriptográfia")))((("kriptográfia", "elliptikus görbékre épülő kriptográfia")))A bitcoin pénztárca kulcspárok halmazát tartalmazza. Mindegyik kulcspár egy titkos és egy nyilvános kulcsból áll. A (k) titkos kulcs egy szám, melyet általában véletlenszerűen választanak. A titkos kulcsból elliptikus görbén történő szorzással, ami egy egyirányú titkosító függvény, egy (K) nyilvános kulcsot állítunk elő. A (K) nyilvános kulcsból egy egyirányú titkosító hash függvénnyel egy (A) bitcoin címet állítunk elő. Ebben a részben először egy titkos kulcsot fogunk előállítani, majd megnézzük, hogy az elliptikus görbén milyen matematikai műveletekkel lehet a titkos kulcsot nyilvános kulccsá átalakítani, és végül a nyilvános kulcsból egy bitcoin címet állítunk elő. A titkos kulcs, nyilvános kulcs és bitcoin cím közötti összefüggést az alábbi ábra mutatja: <<k_to_K_to_A>>

[[k_to_K_to_A]]
.Titkos kulcs, nyilvános kulcs és bitcoin cím
image::images/mbc2_0401.png["privk_to_pubK_to_addressA"]

.Miért használjunk aszimmetrikus titkosítást (nyilvános/titkos kulcsokat)?
****
((("titkosítás", "aszimmetrikus")))((("digitális aláírások", "aszimmetrikus titkosítás és")))((("aszimmetrikus titkosítás")))Miért használ a bitcoin aszimmetrikus titkosítást? Nem tranzakciók titkosítására, hanem _digitális aláírások_ generálására használja. Egy titkos kulccsal és a tranzakció digitális ujjlenyomatával numerikus aláírás állítható elő. Ezt az aláírás csak olyasvalaki állíthatta elő, aki a titkos kulcs ismeretével rendelkezik. Ezzel szemben a nyilvános kulcs és tranzakció ujjlenyomat birtokában bárki _ellenőrizheti_ az aláírást. Az aszimmetrikus titkosítás ezen hasznos tulajdonsága teszi lehetővé bárki számára, hogy minden tranzakció minden aláírását ellenőrizze, miközben biztosítja, hogy csak a titkos kulcsok tulajdonosa állíthat elő érvényes aláírást.
****

[[private_keys]]
==== Titkos kulcsok

((("kulcsok és címek", "áttekintése", "titkos kulcs generálása")))((("figyelem és óvatosság", "titkos kulcsok védelme")))A titkos kulcs egyszerűen egy véletlenszerűen választott szám. A titkos kulcs birtoklása az alapja annak, hogy a felhasználó rendelkezést legyen képes gyakorolni az összes pénz fölött, amely a titkos kulcsnak megfelelő bitcoin címhez tartozik. A titkos kulcs aláírások létrehozására szolgál. Az aláírás azt a célt szolgálja, hogy a felhasználó bizonyítani tudja a tranzakcióban szereplő összegek tulajdonjogát, mielőtt elkölti őket. A titkos kulcsnak egész idő alatt titokban kell maradnia, mert felfedése egy harmadik fél számára azzal lenne egyenértékű, mint ha hozzáférést adnánk neki ahhoz a bitcoinhoz, melyet ez a kulcs biztosít. A titkos kulcsról biztonsági másolatot kell készíteni, és védeni kell, nehogy véletlenül elveszítsük, mert ha elvész, akkor nem tudjuk semmi másból visszaállítani, és az általa biztosított összegek is örökre elvesznek.

[TIP]
====
A bitcoin titkos kulcs csupán egy szám. A titkos kulcs véletlenszerűen, pl. egy kockával, egy darab papírral és ceruzával is előállítható. Dobjunk fel egy pénzérmét 256-szor, és írjuk le a dobások eredményét egy bináris szám formájában. A nyilvános kulcs ezt követően a titkos kulcsból állítható elő.
====

===== A titkos kulcs előállítása egy véletlen számból

A kulcsok előállításának első és legfontosabb lépése, hogy egy biztonságos entrópiaforrást, másképpen véletlenszerű forrást találjunk. Egy bitcoin kulcs előállítása lényegében egyenértékű azzal, hogy „Válasszunk egy számot 1 és 2^256^ között”. Hogy pontosan hogyan választjuk ezt a számot, az nem számít, feltéve, hogy a választás nem megjósolható vagy nem megismételhető. A bitcoin szoftver a mögöttes operációs rendszer véletlenszám generátorát használja 256 bit entrópia (véletlenszerűség) előállítására. Az OS véletlenszám generátorát általában egy emberi eredetű entrópiaforrással inicializálják, ezért van szükség pl. arra, hogy mozgassuk az egeret néhány másodpercig.

Pontosabban, a titkos kulcs egy +0+ és +n - 1+ közötti (inkluzív) tetszőleges szám lehet, ahol n konstans (n=1,1578 * 10^77^, vagyis egy kicsit kevesebb, mint 2^256^), és a bitcoinnál használt elliptikus görbe rendszámával egyenlő (lásd az <<elliptic_curve>> részt). Egy ilyen kulcs előállításához véletlenszerűen válasszunk egy 256 bites számot, és ellenőrizzük, hogy kisebb-e +n+-nél. Programozási szempontból ezt általában úgy valósítható meg, hogy kriptográfiailag biztonságos véletlen forrásból származó bitek egy nagyobb halmazát egy SHA256 hash algoritmussal összetömörítjük, és ezzel egyszerűen létrehozunk egy 256 bites számot. Ha az eredmény kisebb, mint +n+, akkor a titkos kulcs megfelelő. Ha nem, akkor egy másik véletlen számmal próbálkozunk.

[WARNING]
====
((("véletlenszámok", "véletlenszám generálás")))((("entrópia", "véletlenszám generálás")))Ne próbálkozzanak azzal, hogy saját pszeudo-véletlenszám generátort (PRNG, pseudo random number generator) írnak, vagy a kedvenc programozási nyelvük által felkínált "egyszerű" véletlenszám generátort használják. Használjanak egy kriptográfiailag biztonságos pszeudo-véletlenszám generátort (CSPRNG, cryptographically-secure pseudo-random number generator), melynek magja megfelelő entrópiaforrásból származik. A CSPRNG helyes megvalósítása a kulcsok biztonsága szempontjából kritikus fontosságú.
====

Alább egy véletlenszerűen előállított (k) titkos kulcs látható hexadecimális formátumban (256 bit, 64 hexadecimális számjeggyel ábrázolva, ahol mindegyik hexadecimális számjegy 4 bitnek felel meg):

----
1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
----


[TIP]
====
A titkos kulcsok száma a bitcoin esetén 2^256^, ami egy elképzelhetetlenül nagy szám. Decimálisan kb. 10^77^. Összehasonlításképp, a látható világegyetemben becslések szerint kb. 10^80^ atom van.
====

((("dumpprivkey parancs")))A Bitcoin Core kliensben (lásd  <<ch03_bitcoin_client>>) egy új kulcs a +getnewaddress+ paranccsal állítható elő. Biztonsági okokból a kliens csak a nyilvános kulcsot jelzi ki, a titkos kulcsot nem. Ha azt szeretnénk, hogy bitcoind írja ki a titkos kulcsot, használjuk a +dumpprivkey+ parancsot. A +dumpprivkey+ a titkos kulcs kijelzésére ellenőrző összeggel kiegészített 58-as számrendszeri formátumot használ, melyet tárca import formátumnak (WIF, _wallet import format_) hívunk. A WIF formátumot a <<priv_formats>> részben fogjuk részletesebben megvizsgálni. Az előző két paranccsal a következőképpen lehet egy titkos kulcsot előállítani és kijelezni:

----
$ bitcoin-cli getnewaddress
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
$ bitcoin-cli dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
----

A +dumpprivkey+ kinyitja a pénztárcát és kiveszi belőle a +getnewaddress+ parancs által előállított titkos kulcsot. A +bitcoind+ csak akkor képes a nyilvános kulcshoz tartozó titkos kulcs kiírására, ha a pénztárcában mindkettő tárolva van.

[TIP]
=====================================================================
A +dumpprivkey+ parancs a nyilvános kulcsból nem képes előállítani a titkos kulcsot, mivel ez lehetetlen. A parancs egyszerűen csak felfedi azt a titkos kulcsot, amelyet a pénztárca már ismer, és amely a +getnewaddress+ paranccsal lett előállítva.
=====================================================================

[role="pagebreak-before"]
Titkos kulcsok generálására és kiíratására használhatja a Bitcoin Explorer parancssori eszközt is (lásd <<appdx_bx>>) a +seed+, +ec-new+ és +ec-to-wif+ parancsokkal:

----
$ bx seed | bx ec-new | bx ec-to-wif
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
----

[[pubkey]]
==== Nyilvános kulcsok

((("kulcsok és címek", "áttekintése", "nyilvános kulcs kiszámítása")))((("generátor pont")))A nyilvános kulcs a titkos kulcsból, az elliptikus görbén történő szorzással számítható ki: _K_ = _k_ * _G_, ahol _k_ a titkos kulcs, _G_ az ún. _generátor pont_, és _K_ az eredményként kapott nyilvános kulcs. Az ellentétes művelet, az ún. "diszkrét logaritmus meghatározása" – vagyis a _k_ kiszámítása, ha a _K_ ismert – annyira nehéz, hogy egyenértékű azzal, mint ha a _k_ összes lehetséges értékét végigpróbálgatnánk, vagyis olyan, mint egy nyers erőn alapuló keresés. Mielőtt szemléltetnénk, hogyan lehet a titkos kulcsból a nyilvános kulcsot előállítani, vizsgáljuk meg kicsit részletesebben az elliptikus görbékkel történő titkosítást.

[TIP]
====
Az elliptikus görbén történő szorzás egy olyan függvény, amit a kriptográfusok "csapóajtó" függvénynek neveznek: az egyik irányban (szorzás) könnyű, az ellentétes irányban (osztás) lehetetlen elvégezni. A titkos kulcs tulajdonosa könnyen előállíthatja a nyilvános kulcsot, amit megoszthat a világgal annak biztos tudatában, hogy senki se tudja kiszámítani a titkos kulcsot a függvény megfordításával. Ez a matematikai trükk a hamisíthatatlan és biztonságos digitális aláírások alapja, ami a bitcoin tulajdonjogát bizonyítja.
====

[[elliptic_curve]]
==== Elliptikus görbékkel történő titkosítás

((("kulcsok és címek", "áttekintése", "elliptikus görbékkel történő titkosítás")))((("elliptikus görbékkel történő titkosítás", id="eliptic04")))((("titkosítás", "elliptikus görbékkel történő titkosítás", id="Celliptic04"))))Az elliptikus görbékkel történő titkosítás egyfajta aszimmetrikus azaz nyilvános kulcsú titkosítás, amely egy elliptikus görbe pontjain végzett összeadás és szorzás diszkrét logaritmus problémáján alapul.

Alább egy elliptikus görbe látható, hasonló ahhoz, mint amit a bitcoin használ: <<ecc-curve>>

[[ecc-curve]]
[role="smallerthirty"]
.Egy elliptikus görbe
image::images/mbc2_0402.png["ecc-curve"]

A bitcoin az Amerikai Szabványügyi Hivatal (NIST, National Institute of Standards and Technology) által, a +secp256k1+ szabványban definiált elliptikus görbét és matematikai konstansokat használja. A +secp256k1+ elliptikus görbét a következő függvény definiálja:

[latexmath]
++++
\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}
++++

vagy

[latexmath]
++++
\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}
++++

A _mod p_ (p prímszám szerinti modulus) azt jelzi, hogy egy _p_ rendszámú véges mező fölött definiált görbéről van szó, ami úgy is írható, hogy latexmath:[\( \mathbb{F}_p\)], ahol p = 2^256^ - 2^32^ - 2^9^ – 2^8^ -2^7^ - 2^6^ – 2^4^ -1, egy nagyon nagy prímszám.

Mivel ez a görbe a valós számok halmaza helyett egy prím rendszámú véges mező fölött lett definiálva, úgy néz ki, mint két dimenzióban szétszórt pontok halmaza, ami nagyon nehézzé teszi a megjelenítését. A matematikája azonban megegyezik a fenti, valós számok fölött definiált elliptikus görbéével. Például lent ugyanez az <<ecc-over-F17-math>> elliptikus görbe látható egy sokkal kisebb, 17 rendszámú véges mező fölött, ahol a pont-minták egy rácson lettek megjelenítve. A bitcoin +secp256k1+ elliptikus görbéje úgy képzelhető el, mint egy sokkal összetettebb pontminta, egy mérhetetlenül nagy rácson.

[[ecc-over-F17-math]]
[role="smallersixty"]
.Titkosítás elliptikus görbével: egy F(p) elliptikus görbe megjelenítése, p=17 esetén
image::images/mbc2_0403.png["ecc-over-F17-math"]

Lent például egy P(x, y) pont látható, amely a +secp256k1+ görbén van.

----
P = (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424)
----

Ezt egy Python programmal önök is ellenőrizhetik (<<example_4_1>>):

[[example_4_1]]
.Python használatával megbizonyosodhatunk arról, hogy ez a pont az elliptikus görbén fekszik
====
[source, pycon]
----
Python 3.4.0 (default, Mar 30 2014, 19:23:13)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
>>> y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
>>> (x ** 3 + 7 - y**2) % p
0
----
====

Az elliptikus görbék matematikája tartalmaz egy "végtelenben lévő" pontot, amely durván a nullának felel meg az összeadásban. A számítógépeken néha az x = y = 0 segítségével ábrázolják (amely nem elégíti ki az elliptikus görbék egyenletét, de könnyen ellenőrizhető külön esetként kezelhető).

Van továbbá egy "összeadásnak" nevezett pass:[+] művelet, amelynek néhány sajátossága hasonlít az iskolában tanult valós számok összeadásához. Ha az elliptikus görbén van két pont, P~1~ és P~2~, akkor létezik egy harmadik pont, P~3~, amely szintén az elliptikus görbén van, és amelyre P~3~ = P~1~ + P~2~.

Geometriailag ez a harmadik pont, a P~3~ úgy számítható ki, hogy húzunk egy egyenest a P~1~ és P~2~ között. Ez az egyenes az elliptikus görbét pontosan egy további helyen fogja metszeni. Nevezzük ezt a pontot P~3~'-nek: P~3~' = (x, y). A P~3~ pont ennek a pontnak az x tengelyre történő tükrözésével kapható meg: P~3~ = (x, -y).

Van néhány különleges eset, amely megvilágítja, miért van szükség a "végtelenben lévő pontra".

Ha a P~1~ és a P~2~ pont megegyezik, akkor a P~1~ és P~2~ "közötti" egyenes a görbe P~1~ pontbeli érintője lesz. Az érintő pontosan egy pontban fogja metszeni a görbét. A differenciálszámítás segítségével meghatározható az érintő meredeksége. Ezek a módszerek érdekes módon még akkor is működnek, ha csak azok a görbén lévő pontok érdekelnek minket, melyeknek mindkét koordinátája egész szám!

In some cases (i.e., if P~1~ and P~2~ have the same x values but different y values), the tangent line will be exactly vertical, in which case P~3~ = "point at infinity."

Ha P~1~ a "végtelenben lévő pont", akkor P~1~ + P~2~ = P~2~. Hasonlóképpen, ha a P~2~ a végtelenben lévő pont, akkor P~1~ + P~2~ = P~1~. Ez mutatja, hogy a végtelenben lévő pont a nulla szerepét játssza.

A pass:[+] asszociatív, vagyis A pass:[+] B) pass:[+] C = A pass:[+] (B pass:[+] C). Ez azt jelenti, hogy A pass:[+] B pass:[+] C zárójelezés nélkül is egyértelmű.

Az összeadás definiálása után az szorzást a szokásos módon, az összeadás kiterjesztéseként definiálható. Az elliptikus görbén lévő P pontra, ha k egész szám, akkor kP = P + P + … + P (k-szor). Megjegyezzük, hogy a k-t néha zavaró módon "kitevőnek" hívják.((("", startref="eliptic04")))((("", startref="Celliptic04")))

[[public_key_derivation]]
==== Egy nyilvános kulcs előállítása

((("kulcsok és címek", "áttekintése", "nyilvános kulcs előállítása")))((("generátor pont")))Kiindulópontunk egy titkos kulcs, amely egy véletlenszerűen előállított _k_ szám, majd ezt megszorozzuk a görbe egy előre meghatározott  _G_ pontjával, a _generátor ponttal_, és ezzel egy másik pontot állítunk elő valahol a görbén, ami megfelel a _K_ nyilvános kulcsnak. A generátor pontot a +secp256k1+ szabvány definiálja, és mindegyik bitcoin kulcs esetén ugyanaz.

[latexmath]
++++
\begin{equation}
{K = k * G}
\end{equation}
++++

ahol _k_ a titkos kulcs, _G_ a generátor pont, és _K_ az eredményként kapott nyilvános kulcs, azaz a görbe egy másik pontja. Mivel a generátor pont az összes bitcoin felhasználó esetén ugyanaz, egy _k_ titkos kulcs _G_-vel vett szorzata mindig ugyanazt a _K_ nyilvános kulcsot eredményezi. A _k_ és _K_ közötti kapcsolat rögzített, de csak az egyik irányban lehet könnyen kiszámítani, _k_-tól _K_ irányában. A bitcoin címet (amely _K_-ból van leszármaztatva) emiatt lehet bárkivel megosztani, és emiatt nem fedi fel a felhasználó titkos kulcsát (_k_).

[TIP]
====
Egy titkos kulcsból kiszámítható a nyilvános kulccsá, de egy nyilvános kulcsot nem lehet titkos kulccsá visszaalakítani, mert a számítás csak egy irányban működik.
====

Az elliptikus görbén történő szorzást úgy valósítjuk meg, hogy az előzőleg előállított _k_ titkos kulcsot megszorozzuk a G generátor ponttal, ami a _K_ nyilvános kulcsot eredményezi:

----
K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G
----

A _K_ nyilvános kulcs definíció szerint egy pont: +K = (x,y)+:

----
K = (x, y)

ahol

x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

Egy pont és egy egész szorzatának megjelenítésére egy egyszerűbb, valós számokon definiált elliptikus görbét fogjuk használni – a matematika ugyanaz. A célunk az, hogy előállítsuk a _G_ generátor pont _kG_ többszörösét. Ez ugyanaz, mint ha a _G_-t _k_-szor összeadnánk. Az elliptikus görbék esetén egy pont önmagával történő összeadása egyenértékű azzal, hogy egy érintőt húzunk az adott pontban, és megkeressük, hogy hol metszi az érintő a görbét, majd ezt a pontot tükrözzük az x-tengelyen.

A <<ecc_illustrated>> ábra a _G_, _2G_, _4G_ előállításának folyamatát mutatja, a görbén végzett geometriai műveletek formájában.

[TIP]
====
((("secp256k1 optimized C library"))A bitcoin a https://github.com/bitcoin-core/secp256k1[secp256k1 optimalizált C könyvtárat] használja, elliptikus görbén végzett számítások végrehajtására.((("", startref="KAover04")))
====

[[ecc_illustrated]]
.Elliptikus görbével történő titkosítás: a G pont és egy egész szorzatának megjelenítése egy elliptikus görbén
image::images/mbc2_0404.png["ecc_illustrated"]

=== Bitcoin címek

((("kulcsok és címek", "bitcoin címek", id="KAaddress04")))A bitcoin cím egy számokból és betűkből álló string, amely bárkivel megosztható, aki pénz akar önöknek küldeni. A nyilvános kulcsból előállított címek betűket és számokat tartalmaznak, és az „1” számjeggyel kezdődnek. Példa egy bitcoin címre:

----
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
----


A tranzakciókban a bitcoin cím leggyakrabban a pénz „címzettjét” azonosítja. Ha összehasonlítjuk a bitcoin tranzakciót egy papír csekkel, akkor a bitcoin cím felel meg a kedvezményezettnek, vagyis ezt írjuk a „Kinek fizetendő” sor után. Papír csekk esetén a kedvezményezett néha egy bankszámlaszám, de lehet cég, intézmény vagy akár pénzt is felvehetünk vele. Mivel a papír csekkeken nem kell számlaszámot megadni, csak egy absztrakt személyt, aki a pénz címzettje, ezért nagyon rugalmas fizetési eszközt jelentenek. A bitcoin tranzakciók hasonló absztrakciót használnak, a bitcoin címet, ami nagyon rugalmassá teszi őket. A bitcoin cím képviselheti egy nyilvános/titkos kulcspár tulajdonosát, vagy valami mást, pl. egy scriptet, amint azt a <<p2sh>> részben látni fogjuk. Egyelőre vizsgáljuk meg az egyszerű esetet, amikor a bitcoin cím egy nyilvános kulcsból származik és azt képviseli.

((("címek", "előállító algoritmusok")))A bitcoin cím a nyilvános kulcsból egy egyirányú kriptográfiai tömörítés (hashing) használatával áll elő. A „tömörítő algoritmus” vagy egyszerűen „hash algoritmus” egy egyirányú függvény, amely egy tetszőleges méretű bemenet esetén egy ujjlenyomatot vagy „zanzát” (hash-t) állít elő. A kriptográfiai hash függvényeket a bitcoin a bitcoin címekben, a script címekben és a bányászat „munkabizonyíték” algoritmusában széleskörűen használja. A nyilvános kulcsból a bitcoin cím előállítása a következő algoritmusokkal történik: az SHA (Secure Hash Algorithm) és a RIPEMD (RACE Integrity Primitives Evaluation Message Digest), konkrétabban az SHA256 és a RIPEMD160 segítségével.

A _K_ nyilvános kulcsból kiindulva kiszámítjuk a kulcs SHA256 tömörítését, majd az eredmény RIPEMD160 tömörítését. Így egy 160 bites (20 bájtos) számot kapunk:

[latexmath]
++++
\begin{equation}
{A = RIPEMD160(SHA256(K))}
\end{equation}
++++

ahol _K_ a nyilvános kulcs és A az eredményként kapott bitcoin cím.


[TIP]
====
Egy bitcoin cím _nem_ azonos a nyilvános kulccsal. A bitcoin címek a nyilvános kulcsból származnak, egy egyirányú függvény alkalmazásával.
====

A bitcoin címek majdnem mindig „Base58Check” kódolásúak (lásd <<base58>>). Ez a kódolás 58 karaktert (58-as számrendszert) használ, és egy ellenőrző összeggel van kiegészítve, ami segíti az olvashatóságot, és véd a cím beviteli és továbbítási hibák ellen. A Base58Check sok más módon is szerephez jut a bitcoinban, ha egy szám, pl. egy bitcoin cím, egy titkos kulcs, egy titkosított kulcs vagy egy script tömörítésének pontos beírására van szükség. A következő részben megvizsgáljuk a Base58Check kódolás és dekódolás működését, és az így előálló alakokat. A <<pubkey_to_address>> egy nyilvános kulcs bitcoin címmé történő átalakítását szemlélteti.

[[pubkey_to_address]]
.Nyilvános kulcsból bitcoin cím: egy nyilvános kulcs átalakítása bitcoin címmé
image::images/mbc2_0405.png["pubkey_to_address"]

[[base58]]
==== Base58 és Base58Check kódolás

((("kulcsok és címek", "bitcoin címek", "Base58 és Base58check kódolás")))((("Base58 és Base58check kódolás", id="base5804")))((("címek", "Base58 és Base58check kódolás", id="Abase5804")))Azért, hogy a hosszú számok tömören, kevesebb szimbólummal legyenek ábrázolhatók, sok számítógéprendszer vegyes alfanumerikus ábrázolást használ, ahol a számrendszer alapja 10-nél nagyobb. Például míg a szokásos tízes alapú számrendszer 0-tól 9-ig 10 számjegyet használ, a hexadecimális számrendszer 16-ot,  amelyben az A és F közötti betűk jelentik a további hat szimbólumot. Egy hexadecimális formátumban ábrázolt szám rövidebb, mint a neki megfelelő tízes számrendszerbeli szám. Még tömörebb a Base64 ábrázolás, amely a 26 kisbetűt, a 26 nagybetűt, a 10 számjegyet és két további karaktert, a „`+`” és a „/” karaktereket használja bináris adatok szövegként, pl. emailben történő továbbítására. A Base64-et leggyakrabban emailek bináris csatolmányainál használják. A Base58 formátum egy olyan szöveges formátum, melyet a bitcoin és sok más digitális pénz használ. Egyensúlyt teremt a tömör ábrázolás, az olvashatóság, a hibaellenőrzés és a hibamegelőzés között. A Base58 a Base64 egy részhalmaza: a kis- és nagybetűket valamint a számokat használja, de elhagy közülük néhányat, amelyeket gyakran összecserélnek egymással, vagy amelyek némelyik betűtípus esetén egyformának látszanak. A Base58 olyan Base64, melyből hiányzik a 0 (a nulla szám), az O (a nagy o betű), az l (a kis L), az I (a nagy i), valamint a „`+`” és „/”. Vagy egyszerűbben, a Base58 a kis- és nagybetűk valamint a számok halmaza, melyből hiányzik az előbb említett négy karakter (0, O, l, I). <<base58alphabet>> a teljes Base58 ábécét mutatja.

[[base58alphabet]]
.A bitcoin Base-58 ábécéje
====
----
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
----
====


A Base58Check olyan Base-58 kódolási formátum, amely az elírások és továbbítási hibák elleni védelemként beépített hiba ellenőrző kóddal rendelkezik. Az ellenőrző összeg további négy bájt, amely a kódolt adat végén áll. Az ellenőrző összeg a kódolt adat tömörítéséből származik, emiatt gépelési hibák felfedésére és megelőzésére használható. A dekódoló szoftver egy Base58Check kód esetén kiszámítja az adat ellenőrző összegét, és összehasonlítja a kódban lévő ellenőrző összeggel. Ha a kettő nem egyezik meg, akkor hiba történt, és a Base58Check adat érvénytelen. Ezen a módon megelőzhető, hogy egy elgépelt bitcoin címet a pénztárca alkalmazás érvényes címként fogadjon el. Az ellenőrzés hiányában egy gépelési hiba a pénz elvesztéséhez vezetne.

Egy tetszőleges adat (szám) Base58Check formátumba történő átalakítása úgy történik, hogy az adathoz egy előtagot adunk hozzá, az úgynevezett „verzió bájt”-ot, ami a kódolt adat adattípusának egyszerű azonosítására szolgál. Például a bitcoin címek esetében ez az előtag nulla (0x00 hexadecimálisan), míg a titkos kulcsok esetében 128 (0x80 hexadecimálisan). A leggyakoribb előtagokat a <<base58check_versions>> táblázat mutatja.

Ezután kiszámítjuk a „kettős-SHA” ellenőrző összeget, vagyis az SHA256 hash algoritmust az előző eredményen kétszer alkalmazzuk:

----
checksum = SHA256(SHA256(prefix+data))
----

Az eredményként kapott 32 bájtos hashből (a hash hashéből) csak az elő négy bájtot használjuk. Ez a négy bájt szolgál hibaellenőrző kódként vagy ellenőrző összegként. Az ellenőrző összeget hozzáadjuk a cím végéhez.

Az eredmény három részből tevődik össze: egy előtagból, az adatból és az ellenőrző összegből. Az eredményt az előzőleg leírt Base58 ábécével kódoljuk. A <<base58check_encoding>> szemlélteti a Base58Check kódolási folyamatát.

[[base58check_encoding]]
.Base58Check kódolás: bitcoin adatok egyértelmű kódolása 58-as számrendszerben, verziószámmal és ellenőrző összeggel
image::images/mbc2_0406.png["Base58CheckEncoding"]

A bitcoin esetén a felhasználó számára megjelenített legtöbb adat Base58Check kódolású, mert így az adatok tömörek, könnyen olvashatók és a hibák szempontjából könnyen ellenőrizhetők. A Base58Check kódolásban használt verzió előtag lehetővé teszi, hogy egymástól könnyen megkülönböztethető formátumokat hozzunk létre. Az előtag Base-58-ban kódolva a Base58Check kódolt formátum egy adott karaktere lesz, ami az emberek számára is könnyűvé teszi az adattípusok felismerését és használatát. Ez különbözteti meg például az „1”-essel kezdődő Base58Check formátumban kódolt bitcoin címet a „5”-sel kezdődő WIF titkos kulcstól. Néhány minta előtag és az eredményként kapott Base-58 karakterek a <<base58check_versions>> táblázatban láthatók.

[[base58check_versions]]
.Base58Check verzió előtagok és a kódolt eredmények 
[options="header"]
|=======
|Típus| Verzió előtag (hexa)| A Base58 eredmény előtagja
| Bitcoin cím | 0x00 | 1
| FIzetés-Script-Hash-nek cím | 0x05 | 3
| Bitcoin Testnet cím | 0x6F | m vagy n
| WIF titkos kulcs |  0x80 | 5, K vagy L
| BIP-38 kódolt titkos kulcs | 0x0142 | 6P
| BIP-32 kiterjesztett nyilvános kulcs | 0x0488B21E | xpub
|=======

==== Kulcs formátumok

((("kulcsok és címek", "bitcoin címek", "kulcs formátumok")))Mind a titkos, mind  a nyilvános kulcs számos különböző formátumban ábrázolható. A különféle ábrázolási módok ugyanazt a számot ábrázolják, még ha különbözőnek látszanak is. Ezeket a formátumok főként arra használatosak, hogy megkönnyítsék a kulcsok leírását és megadását, és védjenek a hibák ellen.

[[priv_formats]]
===== Titkos kulcs formátumok

A titkos kulcs különböző formátumokban ábrázolható, melyek mindegyike ugyanannak a 256 bites számnak felel meg. <<table_4-2>> három gyakori titkos kulcs formátumot mutat. Különböző helyzetekben különböző formátumok használatosak. A hexadecimális és nyers bináris formátumokat belső ábrázolásra használják és ritkán mutatják meg a szoftver felhasználójának. A WIF különböző pénztárcák közötti importálásra/exportálásra használható, és gyakran használják QR kódos (vonalkódos) megjelenítésben.

[[table_4-2]]
.Egy titkos kulcs ábrázolási módjai (kódolási formátumok)
[options="header"]
|=======
|Típus|Előtag|Leírás
| Nyers | Nincs | 32 bájt
| Hexa | Nincs | 64 hexadecimális számjegy
| WIF | 5 | Base58Check kódolás: Base58, verzió előtaggal (128) és egy 32 bites ellenőrző összeggel
| tömörített WIF | K vagy L | Mint előbb, de a kódolás előtt a 0x01 utótag hozzáfűzése
|=======

A <<table_4-3>> ebben a három formátumban tartalmazza ugyanazt a privát kulcsot.

[[table_4-3]]
.Példa: Ugyanaz a kulcs, különböző formátumok 
[options="header"]
|=======
|Formátum | Titkos kulcs
| Hexa | 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
| WIF | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
| tömörített WIF | KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
|=======

Az összes fenti alak ugyanazt a számot, ugyanazt a titkos kulcsot ábrázolja. Ezek különbözőnek látszanak ugyan, de bármelyik formátum könnyen átalakítható bármelyik másik formátumra. A "nyers bináris" alak nem jelenik meg <<table_4-3>> táblázatban, mivel az definíció szerint nem tartozik a megjelenítésre alkalmas kódolások közé.

A Bitcoin Explorer +wif-to-ec+ parancsával (lásd <<appdx_bx>>) tudjuk megmutatni, hogy mindkét WIF kulcs ugyanannak a titkos kulcsnak felel meg:

----
$ bx wif-to-ec 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd

$ bx wif-to-ec KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
----

===== A Base58Check formátum dekódolása

A Bitcoin Explorer parancsaival (lásd <<appdx_bx>>) könnyen tudunk bitcoin kulcsokat, címeket és tranzakciókat kezelő shell scripteket és "pipe"-okat írni. A Bitcoin Explorerrel a következőképpen lehet a parancssorban dekódolni a Base58Check formátumot:

A +base58check-decode+ parancsot használjuk a tömörítetlen kulcs dekódolására:

----
$ bx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
wrapper
{
    checksum 4286807748
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
    version 128
}
----

Az eredmény a kulcsot (hasznos tartalom, payload), a WIF előtagját (128) és az ellenőrző összeget tartalmazza.

Figyelje meg, hogy a tömörített kulcs "hasznos tartalmához" a +01+ utótag lett hozzáfűzve, ami azt jelzi, hogy tömörített kulcsot szeretnénk előállítani:

----
$ bx base58check-decode KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
wrapper
{
    checksum 2339607926
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01
    version 128
}
----

===== Hexadecimális formátum átalakítása Base58Check formátumba

Ha hexadecimális formátumból Base58Check formátumba szeretnénk átalakítást végezni (az előző parancs ellentettje), akkor a Bitcoin Explorer +base58check-encode+ parancsát használhatjuk (lásd <<appdx_bx>>). A hexadecimális titkos kulcs után a WIF verzió előtagot, a 128-at kell megadni:

----
bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd --version 128
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
----

===== Tömörített hexadecimális kulcs kódolása Base58Check formátumba

Ha „tömörített” titkos kulcsként (lásd <<comp_priv>>) szeretnénk a kulcsot Base58Check kódolással előállítani, akkor hozzáadjuk a +01+ utótagot a hexa kulcshoz, majd az előző részhez hasonlóan elvégezzük a kódolást:

----
$ bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 --version 128
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
----

Az eredményként kapott WIF tömörített formátum „K”-val kezdődik, ami azt jelzi, hogy a titkos kulcsnak egy „01” utótagja van, és csak tömörített nyilvános kulcsok hozhatók létre belőle (lásd a <<comp_pub>> részt).

===== Nyilvános kulcs formátumok

((("nyilvános és titkos kulcsok","nyilvános kulcs formátumok")))A nyilvános kulcsok szintén többféle formátumban ábrázolhatók, általában _tömörített_ vagy _nem tömörített_ nyilvános kulcsként.

Mint azt előzőleg láttuk, a nyilvános kulcs az elliptikus görbe egy pontja, amely egy +(x,y)+ koordinátapárból áll. Általában a +04+ előtaggal ábrázolják, melyet két 256-bites szám követ, az egyik a pont _x_-koordinátája, a másik az _y_-koordinátája. A +04+ előtag különbözteti meg a nem tömörített nyilvános kulcsokat a tömörített nyilvános kulcsoktól, melyek +02+-vel vagy +03+-mal kezdődnek.

Alább a fenti titkos kulcsból előállított nyilvános kulcs +x+ és +y+ koordinátája látható.

----
x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

Ugyanez a nyilvános kulcs egy 520-bites számként (130 hexa számjegyként), a +04+ előtaggal, melyet az +x+ és az +y+ koordináta követ:

++++
<pre data-type="programlisting">
K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A&#x21b5;
07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
</pre>
++++

[[comp_pub]]
===== Tömörített nyilvános kulcsok

((("nyilvános és titkos kulcsok", "tömörített nyilvános kulcsok")))A tömörített nyilvános kulcsokat azért vezették be a bitcoinban, hogy csökkentsék a tranzakciók méretét és tárhelyet takarítsanak a teljes bitcoin blokklánc adatbázist tároló csomópontokon. A legtöbb tranzakcióban szerepel a nyilvános kulcs, amely a tulajdonos személyazonosságának tanúsítására és a bitcoin elköltésére szolgál. Mindegyik nyilvános kulcs 520 bit hosszú (előtag + x + y), ami összeszorozva a blokkban lévő több száz tranzakcióval, vagy a napi több tízezer tranzakcióval jelentős adatmennyiséget tesz ki a blokkláncon.

Amint azt a <<pubkey>> részben láttuk, a nyilvános kulcs egy (x,y) pont az elliptikus görbén. Mivel a görbe egy matematikai függvénynek felel meg, a görbén lévő pont a görbe egyenletének egy megoldását jelenti. Ezért ha ismerjük az _x_-koordinátát, akkor az _y_-koordinátát az y^2^ mod p = (x^3^ + 7) mod p egyenlet megoldásával számíthatjuk ki. Ez lehetővé teszi, hogy a nyilvános kulcsban csak az _x_-koordinátáját tároljuk, és elhagyhassuk az _y_-koordinátát. Ily módon 256 bittel csökkenthető a tároláshoz szükséges hely. Ezzel  majdnem 50%-kal csökken minden tranzakció mérete, ami idővel nagyon nagy helymegtakarításhoz vezet.

Míg a nem tömörített nyilvános kulcsoknak +04+ az előtagja, a tömörített kulcsok +02+-vel vagy +03+-mal kezdődnek. Vizsgáljuk meg, miért van két lehetséges előtag! Mivel az egyenlet bal oldalán y^2^ áll, az _y_ megoldás pozitív vagy negatív lehet. Képileg ez azt jelenti, hogy az _y_-koordináta az _x_-tengely felett vagy az _x_-tengely alatt lehet. Amint azt az elliptikus görbe <<ecc-curve>> ábrázolásán láthatjuk, a görbe szimmetrikus, ami azt jelenti, hogy az x-tengelyre tükrös. Emiatt, ha el is hagyhatjuk az _y_ koordinátát, az y _előjelét_ (pozitív vagy negatív) tárolnunk kell, más szóval, tudnunk kell, hogy az x-tengely felett vagy alatt volt-e, mivel mindkét lehetőséghez egy különböző pont és egy különböző nyilvános kulcs tartozik. Ha az elliptikus görbét a p-rendű véges mezőn számítjuk ki, az _y_ koordináta páros vagy páratlan lehet, ami megfelel a fenti pozitív vagy negatív előjelnek. Ezért aztán ha szeretnénk megkülönböztetni az y lehetséges értékeit, akkor a tömörített nyilvános kulcsot +02+ előtaggal tároljuk, ha az _y_ páros, és +03+-mal, ha páratlan, ami lehetővé teszi, hogy egy program az _x_-koordinátából helyesen meg tudja állapítani az _y_-koordináta értékét, és a tömörített nyilvános kulcsból a pont mindkét koordinátáját előállítsa. A nyilvános kulcs tömörítését az <<pubkey_compression>> szemlélteti.

Íme, ugyanaz a nyilvános kulcs, melyet előzőleg láttunk, tömörített nyilvános kulcsként, 264 biten (66 hexa számjeggyel) tárolva. A +03+ előtag azt jelzi, hogy az _y_ koordináta páratlan:

----
K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
----

Ez a tömörített nyilvános kulcs ugyanannak a titkos kulcsnak felel meg, ami azt jelenti, hogy ugyanabból a titkos kulcsból lett előállítva. Mégis különbözőnek látszik a nem tömörített nyilvános kulcstól. Még fontosabb, hogy ha ezt a tömörített nyilvános címet a kétszeres hash függvénnyel (+RIPEMD160(SHA256(K))+) bitcoin címmé alakítjuk át, akkor egy másik bitcoin címet kapunk. Ez zavaró lehet, mert azt jelenti, hogy ugyanabból a titkos kulcsból két _különböző_ nyilvános kulcs állítható elő, mely két különböző formátumban ábrázolható (tömörítve és nem tömörítve), ami két különböző bitcoin címet eredményez. Ugyanakkor a titkos kulcs mindkét bitcoin cím esetén azonos.

[[pubkey_compression]]
[role="smallerseventy"]
.A nyilvános kulcs tömörítése
image::images/mbc2_0407.png["pubkey_tömörítés"]

A tömörített nyilvános kulcsok lassanként alapértelmezettek lesznek a különféle bitcoin klienseken belül, ami jelentős hatással van a tranzakciók méretének csökkentésére, és emiatt a blokkláncra. De még nem mindegyik kliens támogatja a tömörített nyilvános kulcsokat. Az újabb klienseknek, melyek támogatják a tömörített nyilvános kulcsokat, számolniuk kell a tömörített nyilvános kulcsokat nem támogató, régebbi kliensekből származó tranzakciókkal. Ez különösen fontos akkor, ha egy pénztárca alkalmazás titkos kulcsokat importál egy másik pénztárca alkalmazásból, mert az új pénztárcának végig kell pásztáznia a blokkláncot, ha szeretné megtalálni az importált kulcsokhoz tartozó tranzakciókat. Melyik bitcoin címet kell a bitcoin pénztárcának végigpásztáznia? A nem tömörített nyilvános kulcs által előállított bitcoin címet, vagy a tömörített nyilvános kulcshoz tartozó bitcoin címet? Mindkettő érvényes bitcoin cím, és mindkettő aláírható a titkos kulccsal, de mégis két külön címről van szó!

A kérdés megoldása érdekében a titkos kulcsok pénztárcából történő kiexportálásakor a titkos kulcsokat ábrázoló WIF formátum az újabb pénztárcák esetében eltérő módon lett megvalósítva, hogy azt is jelezze, ha a titkos kulcsok _tömörített_ nyilvános kulcsok előállítására szolgálnak, és ennek megfelelően tömörített bitcoin címek tartoznak hozzájuk. Ez lehetővé teszi, hogy az importálást végző pénztárca különbséget tudjon tenni a régebbi vagy újabb pénztárcákból származó titkos kulcsok között, és a blokkláncon azokat a tranzakciókat keresse meg, melyek a megfelelő nem tömörített vagy tömörített nyilvános kulcsokhoz tartozó bitcoin címeknek felelnek meg. Nézzük meg részletesebben, hogyan megy mindez végbe.

[[comp_priv]]
===== Tömörített titkos kulcsok

((("nyilvános és titkos kulcsok", "tömörített titkos kulcsok")))A „tömörített titkos kulcs” elnevezés helytelen, mert a titkos kulcs kiexportálása WIF-tömörített titkos kulcsként történik, és valójában egy bájttal _hosszabb_, mint a „tömörítetlen” titkos kulcs. Ennek az az oka, hogy a titkos kulcs egy egybájtos utótaggal végződik (hexában 01, melyet <<table_4-4>> mutat), ami azt jelzi, hogy a titkos kulcs egy újabb, modern pénztárcából származik, és csak tömörített nyilvános kulcsok előállítására szabad használni. Maguk a titkos kulcsok nincsenek tömörítve és nem tömöríthetők. A „tömörített titkos kulcs” kifejezés valójában azt jelenti, hogy „olyan titkos kulcs, melyből tömörített nyilvános kulcsot kell előállítani”, míg a „nem tömörített titkos kulcs” azt jelenti, hogy „olyan titkos kulcs, melyből nem tömörített nyilvános kulcsot kell előállítani”. Az export formátumra „WIF-tömörített” vagy „WIF” formátumként érdemes hivatkozni, és a titkos kulcsnál a további félreértések elkerülése érdekében el kell felejteni a „tömörítés” szót.

A <<table_4-4>> ugyanazt a kulcsot mutatja, WIF és WIF-tömörített formátumban.

[[table_4-4]]
.Példa: Ugyanaz a kulcs, különböző formátumok 
[options="header"]
|=======
|Formátum | Titkos kulcs
| Hexa | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
| WIF | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
| Tömörített hexa | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01
| tömörített WIF | KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
|=======

Figyelje meg, hogy a tömörített hexa titkos kulcs formátumnak egy extra bájt van a végén (01 hexában). Amíg a Base58 kódolt verzió előtag ugyanaz (0x80) a WIF és tömörített WIF formátumok esetén, addig egy bájt hozzáadása a szám végéhez azt eredményezi, hogy a Base58 kódolás megváltozik 5-ről _K_-ra vagy _L_re. Gondoljon erre mint a 100 és 99 decimális számok között különbség Base58 megfelelőjére. A 100 nem csak egy számjeggyel hosszabb a 99-nél, hanem 1-es előtag helyett, 9-es előtaggal rendelkezik. A hosszúság megváltozása hatással van az előtagra. Base58-ban az előtag 5-ről _K_-ra vagy _L_re változik, ahogy a szám hosszúsága egy bájttal megnő.

Megjegyezzük, hogy a kétféle formátum _nem_ cserélhető fel egymással. Egy modern pénztárcában, amely képes a tömörített nyilvános kulcsok kezelésére, a titkos kulcsok mindig WIF-tömörített alakban lesznek kiexportálva (_K_/_L_ előtag). Ha a pénztárca régebbi, és nem használja a tömörített nyilvános kulcsokat, a titkos kulcs mindig WIF formátumban lesz kiexportálva (5 előtag). A cél az, hogy jelezzük a titkos kulcsokat beimportáló pénztárca számára, hogy tömörített vagy tömörítetlen nyilvános kulcsokat és címeket kell-e keresnie a blokkláncban.

Ha a bitcoin pénztárca képes a tömörített nyilvános kulcsok kezelésére, akkor az összes tranzakcióban ezeket fogja használni. A pénztárcában lévő titkos kulcsokból levezethetők a görbén lévő nyilvános pontok, majd megtörténik ezek tömörítése. A pénztárca a tömörített nyilvános kulcsokat fogja bitcoin címek előállítására használni, és ezek szerepelnek majd a tranzakciókban. Ha titkos kulcsokat exportálunk ki egy új pénztárcából, amely támogatja a tömörített nyilvános kulcsokat, akkor a WIF formátum úgy módosul, hogy a titkos kulcs egy 1 bájtos utótaggal (+01+) egészül ki. Ennek a Base58Check kódolásával kapott titkos kulcsot nevezzük „tömörített WIF”-nek, és ez a _K_ vagy az _L_ betűvel kezdődik, ellentétben a régebbi pénztárcákból származó, WIF kódolt (nem tömörített) kulcsokkal, melyek „5”-tel kezdődnek.


[TIP]
====
A „tömörített titkos kulcs” teljesen helytelen elnevezés! A titkos kulcs nincs tömörítve. A WIF-tömörített azt jelenti, hogy a titkos kulcsból csak tömörített nyilvános kulcsot, és az ehhez tartozó bitcoin címet szabad előállítani. A „WIF-tömörített” titkos kulcs egy bájttal hosszabb, mert a +01+ utótaggal rendelkezik, amely megkülönbözteti a „tömörítetlen” titkos kulcstól.((("", startref="KAaddress04")))
====

=== Kulcsok és címek kezelése Cpass:[++]-ban

Tekintsük át a bitcoin cím előállítás teljes folyamatát, a titkos kulcstól a nyilvános kulcson keresztül a kettősen hashelt címig, és végül a Base58Check kódolásig. Az <<addr_example>> részben látható C++ kód lépésről lépésre a teljes folyamatot bemutatja, a titkos kulcstól a Base58Check kódolású bitcoin címig. A példa az <<alt_libraries>> részben bevezetett libbitcoin könyvtár segédfüggvényeit használja.

[[addr_example]]
.A titkos kulcsból egy Base58Check kódolású bitcoin cím létrehozása 
====
[role="c_less_space"]
[source, cpp]
----
include::code/addr.cpp[]
----
====

A kód egy előre definiált titkos kulcsot használ, emiatt minden egyes futásakor ugyanazt a címet hozza létre, amint azt a <<addr_example_run>> mutatja.((("", startref="base5804")))((("", startref="Abase5804")))

[[addr_example_run]]
.A bitcoin címet előállító mintapélda lefordítása és futtatása
====
[source,bash]
----
# Az addr.cpp kód lefordítása
$ g++ -o addr addr.cpp -std=c++11 $(pkg-config --cflags --libs libbitcoin)
# Az addr végrehajtható program futtatása
$ ./addr
Nyilvános kulcs: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa
Cím: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK
----
====

[TIP]
====
A kód <<addr_example_run>> -ben a _tömörített_ nyilvános kulcsból (lásd <<comp_pub>>) egy (+1PRTT...+) bitcoin címet eredményez. Ha a tömörítetlen nyilvános kulcsot használnánk, az másik bitcoin címet (+14K1y...+) eredményezne.
====

=== Kulcsok és címek kezelése Pythonban

((("kulcsok és címek", "Python implementáció", id="KApython04")))((("pybitcointools")))A legátfogóbb Pythonban megírt bitcoin könyvtár Vitalik Buterin https://github.com/vbuterin/pybitcointools[pybitcointools] könyvtára. A <<key-to-address_script>> példában a „bitcoin”-ként beimportált pybitcointools könyvtárral fogjunk különféle formátumú kulcsokat és címeket előállítani:

[[key-to-address_script]]
Kulcs és cím előállítás és formattálás a pybitcointools könyvtárral
====
[source,python]
----
include::code/key-to-address-ecc-example.py[]
----
====

Az <<key-to-address_script_run>> a kód futtatásakor kapott kimenet mutatja:

[[key-to-address_script_run]]
.A key-to-address-ecc-example.py futtatása
====
++++
<pre data-type="programlisting">
$ python key-to-address-ecc-example.py
Private Key (hex) is:
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6
Private Key (decimal) is:
 26563230048437957592232553826663696440606756685920117476832299673293013768870
Private Key (WIF) is:
 5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K
Private Key Compressed (hex) is:
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601
Private Key (WIF-Compressed) is:
 KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S
Public Key (x,y) coordinates is:
 (41637322786646325214887832269588396900663353932545912953362782457239403430124L,
 16388935128781238405526710466724741593761085120864331449066658622400339362166L)
Public Key (hex) is:
 045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec&#x21b5;
243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176
Compressed Public Key (hex) is:
 025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec
Bitcoin Address (b58check) is:
 1thMirt546nngXqyPEz532S8fLwbozud8
Compressed Bitcoin Address (b58check) is:
 14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3
</pre>
++++
====


Az <<ec_math>> egy másik példa, amely a Python ECDSA könyvtárat használja az elliptikus görbén történő számításokhoz, és nem használ semmilyen egyéb speciális bitcoin könyvtárat.

[[ec_math]]
.A bitcoin kulcsoknál használt, elliptikus görbén végzett számítások szemléltetése
====
[source, python]
----
include::code/ec-math.py[]
----
====

Az <<ec_math_run>> mutatja a script futtatása során kapott kimenetet.

[WARNING]
====
<<ec_math>> ((("véletlenszámok", "os.urandom", see="entrópia")))((("entrópia", "os.urandom", see=véletlenszámok")))((("véletlenszámok", "véletlenszám generálás")))((("entrópia", véletlenszám generálás")))az +os.urandom+-ot használja, amely az operációs rendszer által biztosított kriptográfiailag biztonságos véletlenszám generátor (cryptographically secure random number generator (CSRNG)). Vigyázat: az operációs rendszertől függően az +os.urandom+ implementációja _nem_ biztos, hogy elégséges biztonsági szintet vagy megfelelő seedelést nyújt, ezért _nem_ biztos, hogy élesben használható bitcoin kulcsok generálására alkalmas.((("", startref="KApython04")))
====

[[ec_math_run]]
.A Python ECDSA könyvtár installálása és az ec_math.py script futtatása
====
----
$ # Install Python PIP package manager
$ sudo apt-get install python-pip
$ # Install the Python ECDSA library
$ sudo pip install ecdsa
$ # Run the script
$ python ec-math.py
Secret:  38090835015954358862481132628887443905906204995912378278060168703580660294000
EC point: (70048853531867179489857750497606966272382583471322935454624595540007269312627, 105262206478686743191060800263479589329920209527285803935736021686045542353380)
BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873
----
====

=== Kódolt titkos kulcsok (BIP0038)

((("kulcsok és címek", "egyéb fajták", id="KAadvanced04")))A következő részben kulcsok és címek egyéb fajtáira fogunk példákat látni, pl. a kódolt (titkosított) titkos kulcsokra, script és multisig címekre, kérkedő címekre, valamint papír pénztárcákra.

[[p2sh_addresses]]
==== Fizetés script hashnek (P2SH, pay to script hash) címek és több aláírást megkövetelő (multisig) címek

((("kulcsok és címek", "egyéb fajták", "pay-tp-script és multisig (több aláírást megkövetelő) címek")))((("Pay-to-Script Hash (P2SH)", "multisig (több aláírást megkövetelő) címek és")))((("multisig (több aláírást megkövetelő) címek")))((("címek", "multisig (több aláírást megkövetelő) címek")))Mint tudjuk, a hagyományos bitcoin címek „1”-gyel kezdődnek, és a nyilvános kulcsból származnak, a nyilvános kulcs pedig a titkos kulcsból. Az „1”-gyel kezdődő címekre bárki küldhet bitcoint, de csak az tudja elkölteni, aki be tudja mutatni a titkos kulccsal létrehozott megfelelő aláírást és a nyilvános kulcs zanzáját.

((("bitcoin továbbfejlesztési javaslatok", "fizetés-script-hashnek (BIP-16)"))A „3”-mal kezdődő bitcoin címek fizetés-script-hashnek (P2SH) bitcoin címek, melyeket néha hibásan több aláírást megkövetelő, vagy multisig címeknek hívnak. A bitcoin tranzakció kedvezményezettjét a script hashével, nem pedig a nyilvános kulcs tulajdonosával adják meg. Ezt az újítást 2012 januárjában, a BIP-16 keretében vezették be (lásd <<bip0016>>). Az újítás széles körben elterjedt, mert lehetővé teszi, hogy magához a címhez legyen hozzárendelve valamilyen funkcionalitás. A hagyományos, „1” kezdetű bitcoin címeket használó tranzakciók neve (fizetés-nyilvános-kulcs-hashnek (P2PKH, pay-to-public-key-hash). Ezekkel a hagyományos tranzakciókkal szemben, a „3” kezdetű címekre küldött pénzek esetében nem csak egy nyilvános kulcs hashének bemutatására és a tulajdonjogot bizonyító, titkos kulccsal történő aláírására van szükség. A követelmények meghatározása a cím létrehozásakor történik. A cím a hozzá tartozó összes bemenetet ugyanolyan módon korlátozza.

A P2H címet egy tranzakciós scriptből hozzák létre. Ez a tranzakció határozza meg, hogy ki költheti el a tranzakció kimenetét (részletesebben lásd a <<p2sh>> részt). A P2H cím kódolásához ugyanúgy a kettős hash függvényt kell használni, mint a hagyományos bitcoin címeknél, de a nyilvános kulcs helyett a scripten kell a műveletet elvégezni:

----
script hash = RIPEMD160(SHA256(script))
----

Az eredményként kapott „script hash”-t Base58Check segítségével, „5” verzió előtaggal kódolják, ami egy +3+-mal kezdődő címet eredményez. Pl. egy P2SH cím: +3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM+, amelyet a Bitcoin Explorer következő parancsaival lehet előállítani: +script-encode+, +sha256+, +ripemd160+, és +base58check-encode+ (lásd <<appdx_bx>>). A parancsok a következőképpen használhatók:

----
$ echo \
'DUP HASH160 [89abcdefabbaabbaabbaabbaabbaabbaabbaabba] EQUALVERIFY CHECKSIG' > script
$ bx script-encode < script | bx sha256 | bx ripemd160 \
| bx base58check-encode --version 5
3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM
----

[TIP]
====
A P2SH nem feltétlenül egyezik meg egy több aláírást megkövetelő, szabványos multisig tranzakcióval. A P2SH _leggyakrabban_ egy multisig scriptnek felel meg, de más tranzakciótípusok scriptjeit is ábrázolhatja.
====

===== Multisignature címek és P2SH

Jelenleg a P2SH függvényt a leggyakrabban a multisig script esetén alkalmazzák. Mint a multisig script neve is mutatja, a tulajdonjog igazolásához és a pénz elköltéséhez egynél több aláírást követel meg. A bitcoin multisig N kulcs esetén M aláírást követel meg. Ennek M-of-N multisig a neve, ahol M kisebb vagy egyenlő, mint N. például, Bob, az  <<ch01_intro_what_is_bitcoin>> részben megismert kávéház tulajdonos használhat olyan 1-of-2 multisig címeket, amelyeknél az egyik kulcs az övé, a másik a feleségéé, vagyis mindketten el tudják költeni az ilyen címeken lévő zárolt tranzakció kimeneteket. Ez hasonlít a hagyományos bankok "közös számlájához", ahol a számlatulajdonosok bármelyike egyedül is képes számlaműveleteket végezni. Gopeshnek,((("felhasználási esetek", "offshore szerződéses szolgáltatások"))) a webtervezőnek, aki Bob webhelyét tervezte, lehet viszont egy 2-of-3 multisig címe az üzleti vállalkozásához, ami biztosítja, hogy a címről csak akkor lehet pénzt költeni, ha az üzlettársak közül legalább kettő aláírja a tranzakciót.

A <<transactions>> részben fogjuk megvizsgálni, hogyan lehet P2SH tranzakciókat létrehozni és hogyan lehet P2SH tranzakciókról pénzt költeni.

==== Kérkedő címek

((("kulcsok és címek", "egyéb fajták", "kérkedő címek")))((("kérkedő címek", id="vanity04")))((("címek", "kérkedő címek", id="Avanity04")))A kérkedő címek olyan bitcoin címek, melyek olvasható üzeneteket tartalmaznak, például az +1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33+ egy olyan érvényes cím, amely a „Love” (szeret) szót tartalmazza az „1” utáni négy Base-58 betűn. A kérkedő címekhez titkos kulcsok milliárdjait kell generálni és tesztelni, amíg a származtatott bitcoin címben létre nem jön a kívánt minta. Noha a kérkedő címet előállító algoritmusban vannak optimalizálások, a folyamat alapjában véve annak felel meg, hogy véletlenszerűen választunk egy titkos kulcsot, előállítjuk belőle a nyilvános kulcsot, ebből pedig a bitcoin címet, és leellenőrizzük, hogy megfelel-e a kívánt mintának – mindezt milliárdnyiszor megismételve, amíg sikerrel nem járunk.

Ha találtunk egy kérkedő címet, amely megfelel a kívánt mintának, akkor a titkos kulcs épp úgy használható, mint bármely más címnél. A kérkedő címek épp olyan biztonságosak, mint a többi bitcoin cím. Ugyanaz az elliptikus görbékkel történő titkosítás (ECC, Elliptic Curve Cryptography) és biztonságos hash algoritmus (SHA, Secure Hash Algorithm) van mögöttük, mint bármely más cím mögött. Egy adott mintával rendelkező kérkedő címnél sem lehet könnyebben megtalálni a titkos kulcsot, mint bármely más cím esetén.

Az <<ch01_intro_what_is_bitcoin>> fejezetben találkoztunk Eugéniával, aki egy gyermekvédelmi alap vezetője a Fülöp-szigeteken. Tegyük fel, hogy Eugénia egy bitcoin gyűjtést szervez, és a nagyobb reklám érdekében szeretne a gyűjtéshez egy kérkedő bitcoin címet használni. Eugénia egy olyan kérkedő címet fog létrehozni, amely úgy kezdődik, hogy „1Kids”, ezzel is elősegítve a gyűjtést a gyerekek számára. Vizsgáljuk meg, hogyan hozható létre ez a kérkedő cím, és mit jelent mindez Eugénia gyűjtésének a biztonsága szempontjából.((("felhasználási esetek", "jótékonysági adományok", startref="eugeniafour")))

===== Kérkedő címek előállítása

Fontos megértenünk, hogy a bitcoin cím egyszerűen csak egy szám, amely az Base-58 ábécé szimbólumaival van ábrázolva. Az „1Kids” minta keresése az +1Kids11111111111111111111111111111+ és az +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz+ között történhet. Kb. 58^29^ (kb. 1,4 * 10^51^) ilyen cím van ebben a tartományban, és ezek mindegyike úgy kezdődik, hogy „1Kids”. A <<table_4-11>> táblázatban látható az „1Kids” kezdető címek címtartománya.

[[table_4-11]]
.Az „1Kids” kezdetű kérkedő címek tartománya 
|=======
| *Mettől* | +1Kids11111111111111111111111111111+
| | +1Kids11111111111111111111111111112+
| | +1Kids11111111111111111111111111113+
| | +...+
| *Meddig* | +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz+
|=======

Tekintsük úgy az „1Kids” mintát, mint egy számot, és nézzük meg, milyen gyakran található meg ez a minta egy bitcoin címben (lásd <<table_4-12>>). Egy átlagos asztali számítógéppel, melyben nincs semmilyen célhardver, másodpercenként kb. 100 000 kulcs vizsgálható meg.

[[table_4-12]]
.Egy kérkedő cím minta (1KidsCharity) előfordulási gyakorisága és a megtalálásához szükséges idő egy asztali számítógépen 
[options="header"]
|=======
| Hossz | Minta | Gyakoriság | Átlagos keresési idő
| 1 | 1K | 58-ból 1 | < 1 millisec
| 2 | 1Ki| 3364-ből 1 | 50 millisec
| 3 | 1Kid | 195 000-ből 1 | < 2 mp
| 4 | 1Kids | 11 millióból 1 | 1 perc
| 5 | 1KidsC | 656 millióból 1 | 1 óra
| 6 | 1KidsCh | 38 milliárdból 1 | 2 nap
| 7 | 1KidsCha | 2,2 billióból 1 | 3–4 hónap
| 8 | 1KidsChar | 128 billióból 1 | 13–18 év
| 9 | 1KidsChari | 7000 billióból 1 | 800 év
| 10 | 1KidsCharit | 0,4 trillióból 1 | 46 000 év
| 11 | 1KidsCharity | 23 trillióból 1 | 2,5 millió év
|=======


Mint látható, Eugénia nem fogja tudni az „1KidsCharity” címet belátható idő alatt létrehozni, még akkor sem, ha sok ezer számítógépet használ. Minden egyes további karakter 58-szorosára növeli a nehézséget. A hét karakternél hosszabb mintákat általában speciális hardverrel, pl. erre a célra összeépített asztali számítógépekkel keresik, melyekben több grafikus feldolgozó egység (GPU, Graphical Processing Unit) található. Ezek általában olyan újrahasznosított bitcoin bányász „platformok”, melyek bitcoin bányászatra már gazdaságtalanok, de a kérkedő címek keresésére még hatékonyan használhatók. A GPU-val rendelkező rendszereken a kérkedő címek keresése sok nagyságrenddel gyorsabb lehet, mint egy általános célú CPU-n.

Kérkedő címek úgy is előállíthatók, hogy megbízást adunk egy bányász közösségnek, amely ilyen címek keresésére szakosodott, lásd pl. a http://vanitypool.appspot.com[Vanity Pool] web címet. Ez a bányatársaság a GPU hardverrel rendelkező tagok számára lehetővé teszi, hogy a kérkedő címek keresése révén bitcoinhoz jussanak. Egy kis fizetség fejében (0,01 bitcoin, vagyis írásunk idején kb. 5$ ellenében), Eugénia külső megbízást adhat a 7-karakterből álló minta megkeresésére, és ahelyett, hogy egy CPU-n hónapokig keresné a mintát, már néhány órán belül megkapja az eredményt.

Egy kérkedő cím előállítása a nyers erő módszerével történik: kipróbálunk egy véletlen kulcsot, és megnézzük, hogy az így kapott cím illeszkedik-e a kívánt mintával. Ha nem, akkor megismételjük a folyamatot. A <<vanity_miner_code>> egy példát mutat a "kérkedő címek bányászatára", vagyis egy olyan C++ programot mutat be, mellyel kérkedő címek állíthatók elő. A példák a libbitcoin könyvtárat használják, melyet az <<alt_libraries>> részben ismertettünk.

[[vanity_miner_code]]
.Kérkedő cím bányászat
====
[source,cpp]
----
include::code/vanity-miner.cpp[]
----
====

[NOTE]
====
<<vanity_miner_run>> a +std::random_device+-t használja. A megvalósítástól függően ez akár egy kriptográfiailag biztonságos véletlenszám generátor (cryptographically secure random number generator (CSRNG)) is lehet. A UNIX-szerű operációs rendszerek, pl. a Linux esetén ez a +/dev/urandom+-ot használja. A véletlenszám generátor itt csupán szemléltetési célokra szolgál. Éles rendszerben _nem_ használható bitcoin kulcsok előállítására, mivel ez a megvalósítás nem rendelkezik elégséges biztonsággal.
====

Ezt a példát egy pass:[C++] fordítóval kell lefordítani, és össze kell szerkeszteni a libbitcoin könyvtárral (előbb a libbitcoin könyvtárat kell installálni a rendszeren). A példa futtatása úgy lehetséges, hogy a ++vanity-miner++ végrehajtható programot paraméterek nélkül futtatjuk (lásd <<vanity_miner_run>>). A program egy "1kid" kezdetű kérkedő címet próbál találni. 

[[vanity_miner_run]]
.A kérkedő cím bányászatára vonatkozó példa fordítása és futtatása
====
[source,bash]
----
$ # A kód lefordítása g++ -szal
$ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin)
$ # A példa futtatása
$ ./vanity-miner
Kérkedő címet találtam! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YT
Titok: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f
$ # Újrafuttatáskor különböző lesz az eredmény
$ ./vanity-miner
Kérkedő címet találtam! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFn
Secret: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623
# A "time" használatával vizsgálható meg, mennyi ideig tart egy eredmény megtalálása
$ time ./vanity-miner
Kérkedő címet találtam! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXM
Titok: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349

real	0m8.868s
user	0m8.828s
sys	0m0.035s
----
====

A mintapélda néhány másodperc alatt talált egy három karakteres mintát ("kid"), amint azt az időmérésre szolgáló +time+ Unix parancsból láthatjuk. A +search+ keresési minta megváltoztatásával megvizsgálhatjuk, hogy mennyivel több ideig tart egy négy vagy öt karakteres minta megtalálása.

===== A kérkedő címek biztonsága

((("biztonság","kérkedő címek")))A kérkedő címek valódi kétélű kardot jelentenek, mert a biztonság fokozható is, de _csökkenthető is_ velük. Ha a kérkedő címeket a biztonság javítására használjuk, a jellegzetes címek megnehezítik, hogy a támadó a saját címét helyettesítse be, és az ügyfelek neki fizessenek. Sajnos, a kérkedő címek azt is lehetővé teszik, hogy bárki létrehozzon egy olyan címet, ami _hasonlít_ egy másik véletlen címhez, vagy akár egy másik kérkedő címhez, és így be tudja csapni az ügyfeleket.

Eugénia eljárhat úgy, hogy egy véletlenszerűen generált címet tesz közzé (pl. +1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy+), amelyre bárki elküldheti az adományát. Vagy generálhat egy kérkedő címet is, amelynek 1Kids a kezdete, hogy jellegzetesebbé tegye a címet.

Mindkét esetben az egyetlen fix cím használatának (az egyes adományozóknak külön, dinamikusan generált dinamikus címekkel szemben) az a veszélye, hogy egy tolvaj behatolhat a webhelyre, és a saját címével helyettesítheti a címet, ezzel az adományokat magához irányíthatja át. Ha az adományokat fogadó cím számos különböző helyen lett reklámozva, akkor a felhasználók az utalás előtt vizuálisan ellenőrizni tudják a címet, hogy valóban ugyanaz-e a cím, mint amit a webhelyen, a nekik küldött levélben vagy szórólapon láttak. Egy olyan véletlen cím esetében, mint amilyen pl. a +1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy+, az átlagos felhasználó az első néhány karaktert ellenőrzi, például a "1J7mdg"-t, és ha ez egyezik, akkor úgy tekinti, hogy a cím helyes. Ha valaki lopási céllal egy hasonlónak látszó címet állít elő egy kérkedő címet generáló programmal, akkor gyorsan generálható egy olyan cím, melynek első néhány karaktere megegyezik az adománygyűjtés címével.  <<table_4-13>>:

[[table_4-13]]
.Egy véletlen címmel egyező kérkedő cím előállítása
|=======
| *Eredeti véletlen cím* | 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
| *Kérkedő cím (4 kar. egyezés)* | 1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy
| *Kérkedő cím (5 kar. egyezés)* | 1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n
| *Kérkedő cím (6 kar. egyezés)* | 1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX
|=======

Növeli-e egy kérkedő cím a biztonságot? Ha Eugénia azt a kérkedő címet állítja elő, hogy +1Kids33q44erFfpeXrmDSz7zEqG2FesZEN+, a felhasználók a kérkedő karaktereket, valamint _az ezek mögött álló néhány karaktert_ fogják megvizsgálni, pl. a cím "1Kids33" részét. Ez arra kényszeríti a támadót, hogy egy olyan kérkedő címet állítson elő, amely legalább 6 karakter hosszú, de ehhez 3364-szer (58 * 58) több munkára van szükség, mint Eugéniának a 4 karakteres kérkedő címéhez. Lényegében az Eugénia (vagy az általa megfizetett bányászközösség) által elvégzett munka arra „kényszeríti” a támadót, hogy hosszabb kérkedő címet állítson elő. Ha Eugénia egy bányászközösséget fogad föl egy 8 karakter hosszú kérkedő cím előállítására, akkor ezáltal a támadó a 10 karakteres tartományba kényszerül, amelynek személyi számítógépen lehetetlen az előállítása, de még egy célhardverrel vagy bányászközösséggel is nagyon költséges. Ami Eugéniának még megfizethető, a támadónak megfizethetetlen, különösen akkor, ha a csalás által szerezhető pénz arra sem elég, hogy fedezze a kérkedő cím előállításának a költségét.((("", startref="Avanity04")))((("", startref="vanity04")))((("", startref="eugeniafour")))

[[paper_wallets]]
==== Papír pénztárcák

((("kulcsok és címek", "egyéb fajták", "papír pénztárcák")))((("papír pénztárcák", id="paperw04")))((("pénztárcák", "típusai", "papír pénztárcák", id="Wpaper04")))A papír pénztárcák papírra kinyomtatott privát kulcsok. A papír pénztárca kényelemi okokból gyakran a titkos kulcshoz tartozó bitcoin címet is tartalmazza, de ez nem feltétlenül szükséges, mivel a bitcoin cím előállítható a titkos kulcsból. A papír pénztárcák nagyon hatékony módszert jelentenek biztonsági mentések, vagy offline bitcoin tárolók létrehozására. Az offline bitcoin tárolók neve: „hideg tároló”. Mentési mechanizmusként a papír pénztárca védelmet jelent az ellen, nehogy egy számítógép meghibásodásakor elvesszen a kulcs, pl. ha a számítógépnek tönkremegy a merevlemeze, vagy ha ellopják a számítógépet, vagy ha a kulcs véletlenül törlésre kerül. A papír pénztárcák „hideg tárolóként” nagyon biztonságosak a hackerekkel, keyloggerekkel és más számítógépes fenyegetésekkel szemben, ha offline állították elő őket, és soha nem voltak online rendszeren tárolva.

A papír pénztárcák sokféle alakban és méretben léteznek, de lényegében csupán egy papírra kinyomtatott kulcsból és címből állnak. A papír pénztárcáknak ez a legegyszerűbb alakja: <<table_4-14>>

[[table_4-14]]
.A legegyszerűbb papír pénztárca: a bitcoin cím és a titkos kulcs kinyomtatva
[options="header"]
|=======================
|Bitcoin cím|Titkos kulcs (WIF)
|1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x|5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
|=======================


A papír pénztárcák könnyen előállíthatók olyan eszközökkel, mint pl. a _bitaddress.org_ címen található kliens-oldali Javascript generátor. Ez a weblap a kulcsok és a papír pénztárcák előállításához szükséges összes kódot tartalmazza, és a működéséhez nincs szükség Internet kapcsolatra. Használatához mentsük el a HTML oldalt a lokális meghajtónkra vagy egy külső USB meghajtóra. Szakítsuk meg az Internet kapcsolatot, és nyissuk meg az állományt egy webböngészőben. Még jobb, ha egy friss operációs rendszert töltünk be, például egy CDROM-ról bootolható Linuxot. Míg offline vagyunk, az eszköz által generált kulcsok a helyi nyomtatón egy USB kábellel (nem Wifi-vel) kinyomtathatók, ezáltal olyan papírtárcák állíthatók elő, melyek kulcsai csak a papíron léteznek, és soha nem voltak online rendszerben tárolva. Ha ezeket a papír pénztárcákat egy tűz-biztos széfbe tesszük, és bitcoint „küldünk” a bitcoin címeikre, akkor így egy egyszerű, de nagyon hatékony „hideg tárolót” valósítunk meg. A <<paper_wallet_simple>> ábrán egy papír pénztárca látható, amely a bitaddress.org segítségével lett előállítva.

[[paper_wallet_simple]]
.Példa egy egyszerű papírtárcára a bitaddress.org-ról
image::images/mbc2_0408.png[]

((("bitcoin továbbfejlesztési javaslatok", "kódolt titkos kulcsok (BIP-38)")))Az egyszerű papír pénztárcák hátránya az, hogy a kinyomtatott kulcsok sebezhetők a lopással szemben. Ha egy tolvaj hozzáfér a papírtárcához, akkor ellophatja vagy lefényképezheti a kulcsokat, és a birtokába juthat a kulcsok által őrzött bitcoinnak. Egy fejlettebb papír pénztárca rendszer BIP-38 kódolt titkos kulcsokat használ. A papír tárcára kinyomtatott kulcsokat jelmondat védi, melyet a tulajdonos kívülről tud. A jelmondat nélkül a kódolt kulcsok használhatatlanok. Ugyanakkor ez a megoldás még mindig jobb, mint egy jelszóval védett pénztárca, mert a kulcsok soha sem voltak online, és fizikailag kell őket elővenni egy széfből vagy más, fizikailag biztonságos tárolóból. A <<paper_wallet_encrypted>> ábrán egy BIP-38 titkosított titkos kulccsal rendelkező papír pénztárca látható, amely a bitaddress.org segítségével lett létrehozva.

[[paper_wallet_encrypted]]
.Példa egy kódolt papírtárcára a bitaddres.org-ról. A jelmondat: „test”
image::images/mbc2_0409.png[]

[WARNING]
====
Egy papírtárcába akár többször is lehet pénzt küldeni, de a pénzt csak egyszer célszerű belőle felvenni. Ekkor a benne lévő összes pénzt el kell költeni. Ez azért van így, mert némelyik pénztárca a pénz feloldása és elköltése során a visszajáró pénznek egy további, újabb címet állíthat elő, ha nem az egész összeget költjük el. Ha a tranzakció aláírásához használt számítógép kompromittálódik, megnő a titkos kulcs felfedésének veszélye, ami hozzáférést ad a visszajáró címen lévő pénzhez. Ha a papírtárca teljes összegét csak egyszer költjük el, csökkentjük a kulcslopás kockázatát. Ha csak kis összegre van szükségünk, küldjük a maradék pénzt egy új papírtárcába a tranzakcióban.
====

Sokféle méretű és kivitelű papírtárca van, melyeknek különféle tulajdonságaik vannak. Némelyik ajándékul szolgál, és az alkalomhoz illő témáik vannak, pl. karácsonyi vagy újévi jelenetek. Mások arra a célra szolgálnak, hogy egy banki páncélteremben vagy széfben őrizzük őket. Ezeknél a privát kulcs valamilyen módszerrel el van takarva, pl. nem átlátszó, lekaparható matricával, vagy össze van hajtogatva és egy biztonságos öntapadó fóliával van leragasztva. Az alábbi pass:[<a data-type="xref" href="#paper_wallet_bpw" data-xrefstyle="select: labelnumber">#paper_wallet_bpw</a>] és pass:[<a data-type="xref" href="#paper_wallet_spw" data-xrefstyle="select: labelnumber">#paper_wallet_spw</a>] közötti ábrákon különféle papírtárcák láthatók.

[[paper_wallet_bpw]]
.Példa egy papírtárcára a bitcoinpaperwallet.com-ról, ahol a titkos kulcs egy összehajtható fülön van.
image::images/mbc2_0410.png[]

[[paper_wallet_bpw_folded]]
.A bitcoinpaperwallet.com-ról származó papírtárca, ahol a titkos kulcs rejtve van.
image::images/mbc2_0411.png[]

Más típusok leválasztható ellenőrző szelvények formájában a kulcsból és a címből több példányt tartalmaznak, hasonlóan a jegyek ellenőrző szelvényeihez, ezáltal több példányban tárolhatók, ami megvédi őket a tűzesetek, árvizek és más természeti katasztrófák ellen.((("", startref="KAadvanced04")))((("", startref="Wpaper04")))((("", startref="paperw04")))

[[paper_wallet_spw]]
.Példa egy papírtárcára, amely egy tartalék „fülön” a kulcsok további másolatait tartalmazza.
image::images/mbc2_0412.png[]