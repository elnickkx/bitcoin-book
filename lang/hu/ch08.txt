[[bitcoin_network_ch08]]
== A bitcoin hálózat

=== Peer-to-peer hálózati felépítés

((("bitcoin hálózat", "peer-to-peer felépítés")))((("peer-to-peer (P2P)")))A bitcoin az Internetre épülő peer-to-peer hálózati felépítéssel rendelkezik. A peer-to-peer vagy P2P kifejezés azt jelenti, hogy a hálózatban részt vevő csomópontok egyenrangúak, vagyis nincsenek „különleges” csomópontok, és mindegyik csomópont kiveszi a részét abból a teherből, amit a hálózati szolgáltatások nyújtása jelent. A hálózat csomópontjai „egyforma” topológiájú hálózatban kapcsolódnak egymáshoz, nincsenek „szerverek”, központosított szolgáltatások, és a hálózaton belül nincs alá- és fölérendeltség. A P2P hálózatok csomópontjai egyszerre szolgáltatók és fogyasztók, ahol a kölcsönösség a részvétel egyik ösztönzője. A P2P hálózatok nagyon ellenállóak, decentralizáltak és nyitottak. A P2P hálózati architektúrára kiváló példát jelentett maga a korai Internet, ahol az IP hálózat csomópontjai egyenlőek voltak. Manapság az Internet felépítése hierarchikusabb, de az Internet Protokoll még mindig őrzi az egynemű topológia lényegét. A bitcoinon kívül a P2P technológia legnagyobb és legsikeresebb alkalmazása a fájlmegosztás: itt a Napster volt az architektúra úttörője, és a bittorrent a legutóbbi fejleménye.

A Bitcoin P2P hálózati felépítése sokkal több, mint topológia kérdése. A bitcoin egy P2P digitális pénzügyi rendszerként lett megtervezve, és a hálózat felépítése ennek az alapjellemzőnek a tükröződése és a megtestesülése. Az irányítás decentralizálása tervezési alapelv. Ez az alapelv csak egy hierarchia nélküli, decentralizált P2P konszenzus révén valósítható meg és tartható fönn.

((("bitcoin hálózat","definíciója")))A „bitcoin hálózat” kifejezés a bitcoin P2P protokollt futtató csomópontok halmazát jelenti. A bitcoinban a P2P protokollon túlmenően egyéb protokollok is vannak, pl. a Stratum, melyet a bányászatnál vagy pehelysúlyú mobil pénztárcáknál alkalmaznak. Ezeket a további protokollokat a bitcoin hálózathoz kapcsolódó gateway router szolgáltatások biztosítják, melyek a P2P protokollon keresztül kapcsolódnak a bitcoin hálózathoz, és a hálózatot az egyéb protokollokat futtató csomópontok irányában terjesztik ki. Például a Stratum szerverek a bányászatot végző Stratum csomópontokat kapcsolják össze a Stratum protokoll segítségével a fő bitcoin hálózattal, vagyis a Stratum protokollt a bitcoin P2P protokolljával kötik össze. A bitcoin P2P protokolljára, a bányatársaságok protokolljaira, a Stratum protokollra és a bitcoin rendszer részeit összekötő egyéb protokollokra együtt a „kiterjesztett bitcoin hálózat” kifejezéssel hivatkozunk.

=== Csomópont típusok és szerepek

((("bitcoin hálózat","csomópontok típusai és szerepei", id="BNnode08")))((("bitcoin csomópontok", "típusai és szerepei", id="BNtype08")))Noha a bitcoin P2P hálózatában lévő csomópontok egyenértékűek, de attól függően, hogy milyen működési módokat támogatnak, különböző „szerepeket” játszhatnak. Egy bitcoin csomópont a következő funkciókat valósíthatja meg: routing, blokklánc adatbázis, bányászat, pénztárca szolgáltatások. Lent a <<full_node_reference>> ábrán egy teljes csomópont látható, mely mind a négy funkciót támogatja:

[[full_node_reference]]
[role="smallerfifty"]
. Egy bitcoin hálózati csomópont, amely mind a négy funkcióval rendelkezik: hálózati router, blokklánc adatbázis, bányászat és pénztárca (pénztárca, bányász, teljes blokklánc, hálózati router csomópont)
image::images/mbc2_0801.png["FullNodeReferenceClient_Small"]

A hálózat összes csomópontja tartalmazza a router funkciót, hogy a csomópont részt vehessen a hálózatban. A csomópontok egyéb funkciókat is tartalmazhatnak. Valamennyi csomópont ellenőrzi és továbbítja a tranzakciókat és blokkokat, valamint összeköttetéseket hoz létre és tart fönn a többi hálózati csomóponttal. A fenti <<full_node_reference>> teljes csomópont esetében a router funkciót egy „Network Routing Node” (Hálózati router csomópont) feliratú kör, vagy egy „N” betű jelzi.

((("teljes csomópontot megvalósító kliensek")))Vannak olyan csomópontok – ezeket teljes csomópontoknak hívjuk – melyek teljes és naprakész másolatot tartanak fönn a blokkláncról. A teljes csomópontok külső hivatkozás nélkül, önállóan és hitelesen képesek bármely tranzakció ellenőrzésére. Némelyik csomópont csak a blokklánc egy részhalmazát kezeli, és a tranzakciókat az ún. Egyszerűsített Fizetési Ellenőrzés módszerével ellenőrzi (SPV, Simplified Payment Verification). ((("pehelysúlyú kliensek")))Ezek a csomópontok az SPV vagy másképpen pehelysúlyú csomópontok. A fenti teljes csomópont esetében a blokklánc adatbázis funkciót egy „Full Blockchain” (Teljes blokklánc) feliratú kör, vagy „B” betű jelzi. <<bitcoin_network>>-ben az SPV csomópontok „B” kör nélkül szerepelnek, jelezve, hogy ezek nem rendelkeznek a blokklánc teljes másolatával.

((("bitcoin csomópontok", "bányász csomópontok")))((("bányászat és konszenzus", "bányász csomópontok")))((("munkabizonyíték (Proof-of-Work) algoritmus")))((("bányászat és konszenzus", "munkabizonyíték (Proof-of-Work) algoritmus")))A bányász csomópontok új blokkokat hoznak létre oly módon, hogy célhardvert használnak a munkabizonyíték (Proof-of-Work) algoritmus megoldására. Némelyik bányász csomópont egyúttal teljes csomópont is, míg a többiek pehelysúlyú csomópontok, melyek társult bányászatban (pooled mining) vesznek részt, és egy szerverre bízzák a teljes csomópont kezelését. A bányász funkciót a fenti teljes csomópont esetén a „Miner” (Bányász) feliratú kör, vagy az „M” betű jelzi.

A teljes csomópontok pénztárcát is tartalmazhatnak. Az asztali bitcoin kliensek esetében általában ez a helyzet. Egyre több pénztárca, különösen azok, melyek erőforrásokban korlátozott eszközökön, pl. okostelefonokon futnak, SPV csomópontok. A pénztárca funkciót fent <<full_node_reference>> egy „Wallet” (Pénztárca) feliratú kör, vagy egy „W” betű mutatja.

A bitcoin P2P protokollhoz tartozó leggyakoribb csomópont típusokon kívül vannak olyan szerverek és csomópontok, melyek egyéb protokollokat futtatnak, pl. specializált bányász-protokollokat és pehelysúlyú kliens elérési protokollokat.

<<node_type_ledgend>> a kiterjesztett bitcoin hálózat különféle csomópont-típusait mutatja. (Referencia kliens (Bitcoin Core): pénztárcát, bányászt, teljes blokklánc adatbázist és hálózati router csomópontot tartalmaz a bitcoin P2P hálózatban. | Teljes blokklánc csomópont: teljes blokklánc adatbázist és hálózati router csomópontot tartalmaz a bitcoin P2P hálózatban. | Magányos bányász: bányász funkciókat valamint a teljes blokklánc adatbázist, és egy bitcoin P2P hálózati csomópontot tartalmaz. | Pehelysúlyú (SPV) pénztárca: egy pénztárcát és a bitcoin P2P protokollon alapuló hálózati csomópontot tartalmaz, blokklánc nélkül. | Bányatársasági szerverek: gateway routerek, melyek a bitcoin P2P hálózatot más protokollokat futtató csomópontokkal kapcsolják össze, pl. bányatársaságot alkotó csomópontokkal vagy Stratum csomópontokkal | Bányász csomópontok: bányászati funkciókat tartalmaznak, blokklánc nélkül, a Stratum (S) protokoll csomóponttal vagy más bányatársasági (pool, P) protokollal együtt. | Pehelysúlyú (SPV) Stratum pénztárca: egy pénztárcát és egy hálózati csomópontot tartalmaz, amely a Stratum protokollra épül. Blokkláncot nem tartalmaz.)

=== A kiterjesztett bitcoin hálózat

((("", startref="BNnode08")))((("", startref="BNtype08")))((("bitcoin hálózat", "kiterjesztett hálózati működés")))A P2P protokollt futtató fő bitcoin hálózat kb. 5000 és 8000 közötti csomópontból áll. A csomópontok a bitcoin referencia kliens (Bitcoin Core) különféle változatait futtatják. Néhány száz további csomópont a bitcoin P2P protokoll különféle egyéb megvalósításait futtatja, ilyen pl. a Bitcoin Classic, a Bitcoin Unlimited, a BitcoinJ, a Libbitcoin, a btcd és a bcoin. A bitcoin P2P hálózat csomópontjainak kis százaléka bányászatot is végez, vagyis egymással versenyezve részt vesz a bányászatban, ellenőrzi a tranzakciókat és új blokkokat hoz létre. Számos nagy cég úgy teremt kapcsolatot a bitcoin hálózattal, hogy a Bitcoin Core kliensen alapuló teljes csomópontokat futtat, amelyekben szerepel a blokklánc és a hálózat kezelés, de hiányzik belőlük a bányászati és pénztárca funkció. Ezek a csomópontok a hálózat határán lévő routerekként használhatók, és különféle egyéb szolgáltatások ráépítését teszik lehetővé (pénzváltók, pénztárcák, blokk vizsgálók, fizetés feldolgozás).

A kiterjesztett bitcoin hálózat tartalmazza a fent leírt, bitcoin P2P protokollt futtató hálózati csomópontokat, valamint a specializált protokollokat futtató csomópontokat egyaránt. A bitcoin P2P hálózathoz számos bányatársaság szervere kapcsolódik, valamint olyan protokoll gatewayek, melyek a csomópontokat az egyéb protokollokat futtató csomópontokkal kötik össze, többnyire bányász csomópontokkal (lásd <<mining>>), vagy pehelysúlyú kliensekkel, melyek nem tartalmazzák a blokklánc teljes másolatát.

A <<bitcoin_network> a különféle csomópont típusokat, gatewayeket, routereket, pénztárcákat, valamint a közöttük kapcsolatot teremtő protokollokat mutatja.

[[node_type_ledgend]]
.Különféle csomópont típusok a <<bitcoin_network>> kiterjesztett bitcoin hálózaton. (Balról jobbra, felülről lefelé: teljes csomópont, szingli bányászok, Bitcoin Core kliens, Stratum hálózat, Stratum bányászat, pehelysúlyú pénztárcák, bányatársaság bányászai, bányatársaság, teljes csomópont, Edge routerek, SPV pénztárca)
image::images/mbc2_0802.png["BitcoinNodeTypes"]

[[bitcoin_network]]
.A különféle csomópont típusokat, gatewayeket és protokollokat tartalmazó kiterjesztett bitcoin hálózat. (Balról jobbra, felülről lefelé: teljes csomópont, szingli bányászok, Bitcoin Core kliens, Stratum hálózat, Stratum bányászat, pehelysúlyú pénztárcák, bányatársaság bányászai, bányatársaság, teljes csomópont, Edge routerek, SPV pénztárca)
image::images/mbc2_0803.png["BitcoinNetwork"]

=== Bitcoin továbbító hálózatok

((("bitcoin hálózat", "bitcoin továbbító hálózatok")))((("továbbító hálózatok")))Ugyan a bitcoin P2P hálózat számos csomóponttípus általános igényeit kiszolgálja, túl magas hálózati késleltetése miatt nem tudja a bitcoin bányász csomópontok speciális igényeit kielégíteni.

((("terjesztés", "továbbító hálózatok és")))A bitcoin bányászok időérzékeny versenyen vesznek részt a munkabizonyíték probléma megoldása és a blokklánc kibővítése érdekében (lásd <<mining>>). A versenyen való részvétel közben a bitcoin bányászoknak minimálisra kell csökkenteniük a nyertes blokk terjesztése és a következő versenykör kezdete közötti időt. A bányászatban a hálózati késleltetés közvetlenül összefüggésben áll a haszonkulccsal.

A _Bitcoin Relay Network_ olyan hálózat, amely megkísérli minimalizálni a blokkok bányászok közötti átvitelének késleltetését. Az eredeti http://www.bitcoinrelaynetwork.org[Bitcoin Relay Network-öt] Matt Corallo, bitcoin fejlesztő, készítette 2015-ben, hogy lehetővé tegye a blokkok bányászok közötti gyors szinkronizálását nagyon alacsony késleltetés mellett. A hálózat több speciális csomópontból állt, amelyek az Amazon Web Services infrastruktúráján működtek világszerte, és a bányászok és bányatársaságok többségének összekapcsolására szolgáltak.

((("Fast Internet Bitcoin Relay Engine (FIBRE)")))((("kompakt blokk optimalizálás")))2016-ban az eredeti Bitcoin Relay Network helyébe a _Fast Internet Bitcoin Relay Engine_ vagy http://bitcoinfibre.org[_FIBRE_] lépett, amelyet szintén Matt Corallo hozott létre. A FIBRE egy UDP-alapú továbbító hálózat, amely blokkokat továbbít csomópontok egy hálózatán belül. A FIBRE a _kompakt blokk_ optimalizálást valósítja meg, hogy tovább csökkentse az átvitt adatok mennyiségét és a hálózati késleltetést.

((("Falcon Relay Network")))Egy másik továbbító hálózat (egyelőre javaslati fázisban) a http://www.falcon-net.org/about[_Falcon_], amelyet a Cornell Egyetemen végzett kutatások alapján hoztak létre. A Falcon „tárol-és-továbbít” helyett „közvetlen kapcsolást” használ a késleltetés csökkentésére azáltal, hogy már a beérkező részblokkokat továbbítja, ahelyett, hogy a teljes blokk megérkezéséig várna.

A továbbító hálózatok nem helyettesítik a bitcoin P2P hálózatát. Ehelyett olyan overlay hálózatok, amelyek további lehetőségeket biztosítanak speciális igényekkel rendelkező csomópontok közötti összeköttetésekre. Úgy ahogy az autópályák sem a vidéki utak helyettesítésére szolgálnak, hanem inkább gyorsjáratok két forgalmas pont között, továbbra is szükség van kisebb utakra az autópályákra való csatlakozáshoz.

=== Hálózat felderítés

((("bitcoin hálózat", "kiterjesztett hálózat felderítés", id="BNextend08")))((("bitcoin csomópontok", "hálózat felderítés", id="BNodiscover08")))Ahhoz, hogy egy új csomópont részt tudjon venni a hálózatban, a csomópontnak az indulásakor fel kell derítenie, hogy milyen más csomópontok vannak a hálózatban. A folyamat beindításához az új csomópontnak fel kell derítenie a hálózat legalább egy létező csomópontját, és kapcsolódnia kell hozzá. A csomópontok földrajzi elhelyezkedése lényegtelen, a bitcoin hálózat topológiáját nem a földrajzi hely határozza meg. Ezért a csomópont véletlenszerűen, bármelyik létező bitcoin csomópontot választhatja.

A csomópontok egy ismert peerhez TCP összeköttetéssel kapcsolódnak, általában a 8333-as porton (amely a bitcoin „jól ismert” portja), vagy egy alternatív porton, ha megadtak ilyet. Az összeköttetés létrejötte után a csomópont a version (verzió) üzenet elküldésével egy „kézfogást” indít (lásd <<network_handshake>>). A +version+ üzenet azonosító adatokat tartalmaz. Ezek a következők:

+nVersion+:: a kliens által „beszélt” bitcoin P2P protokoll verziója (pl. 70002)
+nLocalServices+:: a csomópont által támogatott helyi szolgáltatások listája, jelenleg csupán a +NODE_NETWORK+ (hálózati csomópont) az egyetlen eleme
+nTime+:: az aktuális idő
+addrYou+:: a távoli csomópont IP címe, ahogyan azt a csomópont látja
+addrMe+:: a helyi csomópont IP címe, ahogyan azt a helyi csomópont látja
+subver+:: az alverzió, amely a csomóponton futó szoftver típusát mutatja (pl. pass:[<span class="keep-together"><code>/Satoshi:0.9.2.1/</code></span>])
+BestHeight+:: a csomópont blokkláncának a blokkmagassága

(A +version+ hálózati üzenetre a http://bit.ly/1qlsC7w[GitHub] web helyen látható példa.)

A +version+ üzenet mindig az első üzenet, amelyet egy peer egy másik peernek küld. A +version+ üzenetet fogadó helyi peer megvizsgálja a távoli peer által jelentett +nVersion+ verziót, és ez alapján eldönti, hogy a távoli peer kompatibilis-e. Ha a távoli peer kompatibilis, akkor a helyi peer visszaigazolja a +version+ üzenetet, és kapcsolatot létesít egy +verack+ üzenet elküldésével.

Hogyan találja meg egy új csomópont a peereket? Az első módszert a DNS-ek lekérdezése jelenti bizonyos "DNS magok" használatával, melyek olyan DNS szerverek, melyek bitcoin csomópontok IP címeinek a listáját adják vissza. A DNS magok némelyike stabil bitcoin csomópontok statikus listáját adja vissza. Vannak olyan DNS magok is, melyek a BIND (Berkeley Internet Name Daemon) egyedi megvalósításai, és bitcoin csomópontok véletlen részhalmazának a címeit adják vissza. Ezek a címek egy crawlerből vagy egy hosszú ideje futó bitcoin csomópontról származnak. A Bitcoin Core kliens öt különböző DNS mag nevét tartalmazza. A DNS magok tulajdonosainak és megvalósításainak a változatos volta biztosítja a kezdeti bootstrap folyamat magas szintű megbízhatóságát. A Bitcoin Core kliensben a +-dnsseed+ kapcsoló szabályozza, hogy a kliens használja-e a DNS magokat, és alapértelemben 1 az értéke.

Ha viszont az induló csomópont semmit sem tud a hálózatról, akkor legalább egy bitcoin csomópont IP címét meg kell adni neki, és ezután már további bemutatkozások révén a többi csomóponttal is kapcsolatba tud lépni. A +-seednode+ parancssori argumentum azt jelzi, hogy a megadott csomóponthoz csak a bemutatkozás kedvéért szeretnénk kapcsolódni, és szeretnénk magként használni. Miután a kezdeti mag csomópont segítségével megtörténtek a bemutatkozások, a kliens lekapcsolódik róla, és az újonnan felfedezett peereket fogja használni.

[[network_handshake]]
.A peerek közötti kezdeti kézfogás
image::images/mbc2_0804.png["NetworkHandshake"]

Miután már létrejött egy vagy több kapcsolat, az új csomópont egy +addr+ üzenetet fog küldeni a szomszédainak, amely tartalmazza a saját IP címét. A szomszédok az +addr+ üzenetet tovább küldik a saját szomszédaiknak, biztosítván ezáltal, hogy a kapcsolódó csomópontok jól ismertek és jobban kapcsolódók legyenek. Az újonnan kapcsolódó csomópont ezen kívül egy +getaddr+ üzenetet is küldhet a szomszédainak, amivel azt kéri tőlük, hogy küldjék el neki a többi peer IP címeit. Ily módon a csomópont meg tudja keresni, mely csomópontokhoz kapcsolódhat, valamint hírt tud adni a saját létéről a hálózaton a célból, hogy a többi csomópont is képes legyen őt megtalálni. A <<address_propagation>> ábrán ((("terjedés", "címterjedés és hálózat felderítés")))a cím felderítési protokoll látható.


[[address_propagation]]
.Címterjedés és hálózat felderítés
image::images/mbc2_0805.png["AddressPropagation"]

Egy csomópontnak kapcsolódnia kell pár darab különböző csomóponthoz, hogy különféle útvonalakon kapcsolódhasson a bitcoin hálózathoz. Az útvonalak nem állandóak, csomópontok jönnek és mennek, emiatt a csomópontnak folytatnia kell az új csomópontok felderítését, mivel a régi kapcsolatai bármikor megszűnhetnek, és emellett segítenie kell a többi csomópont elindulását. Az induláshoz csak egyetlen összeköttetés szükséges, mivel az első csomópont képes bemutatkozásokat felajánlani a peer csomópontoknak, ezek a peerek pedig képesek további bemutatkozásokat felajánlani. A hálózati erőforrások szempontjából szükségtelen és egyúttal pazarló, ha a csomópont pár darab csomópontnál több csomóponthoz kapcsolódik. Az indulás után a csomópont emlékszik a legutolsó sikeres peer kapcsolataira, emiatt újraindítás után az előző peer hálózattal ismét gyorsan létre tudja hozni a kapcsolatait. Ha az előző peerek egyike sem válaszol a kapcsolódási kérésére, akkor a csomópont a mag csomópontokat használja az újrainduláskor.

A Bitcoin Core klienst futtató csomóponton a peer kapcsolatok a +getpeerinfo+ paranccsal listázhatók ki:

[source,bash]
----
$ bitcoin-cli getpeerinfo
----
[source,json]
----
[
    {
        "addr" : "85.213.199.39:8333",
        "services" : "00000001",
        "lastsend" : 1405634126,
        "lastrecv" : 1405634127,
        "bytessent" : 23487651,
        "bytesrecv" : 138679099,
        "conntime" : 1405021768,
        "pingtime" : 0.00000000,
        "version" : 70002,
        "subver" : "/Satoshi:0.9.2.1/",
        "inbound" : false,
        "startingheight" : 310131,
        "banscore" : 0,
        "syncnode" : true
    },
    {
        "addr" : "58.23.244.20:8333",
        "services" : "00000001",
        "lastsend" : 1405634127,
        "lastrecv" : 1405634124,
        "bytessent" : 4460918,
        "bytesrecv" : 8903575,
        "conntime" : 1405559628,
        "pingtime" : 0.00000000,
        "version" : 70001,
        "subver" : "/Satoshi:0.8.6/",
        "inbound" : false,
        "startingheight" : 311074,
        "banscore" : 0,
        "syncnode" : false
    }
]
----

A felhasználók egy IP címekből álló lista megadásával, a +-connect=<IPAddress>+ opcióval tudják felülbírálni a peerek automatikus kezelését. Ennek az opciónak a használatakor a csomópont csak a megadott IP címekhez fog kapcsolódni, és nem fogja automatikusan felderíteni és karbantartani a peer kapcsolatokat.

Ha egy kapcsolaton nincs forgalom, akkor a kapcsolat fenntartása érdekében a csomópont periodikus üzenetküldést végez rajta. Ha a csomópont egy kapcsolata már több mint 90 perce nem volt használva, akkor a csomópont a kapcsolatot szétkapcsolt állapotúnak tekinti, és egy új peer keresésébe kezd. Ily módon a hálózat dinamikusan alkalmazkodni képes a tranziens csomópontokhoz, a hálózati problémákhoz, és központi irányítás nélkül, organikusan képes nőni vagy csökkenni.((("", startref="BNextend08")))((("", startref="BNodiscover08")))

=== Teljes csomópontok

((("bitcoin hálózat", "teljes csomópontok")))((("teljes csomópontot megvalósító kliensek")))((("blokklánc (a)", "teljes blokklánc csomópontok")))A teljes csomópontok olyan csomópontok, melyek az összes tranzakciót tartalmazó, teljes blokkláncot kezelik. Ezeket a csomópontokat pontosabban „a teljes blokkláncot kezelő csomópontoknak” kellene hívni. A bitcoin korai éveiben az összes csomópont teljes csomópont volt, jelenleg a Bitcoin Core kliens kezeli a teljes blokkláncot. Az utóbbi két évben azonban a bitcoin kliensek új fajtái jöttek létre, melyek nem kezelik a teljes blokkláncot, hanem pihesúlyú kliensként futnak. Ezeket a következő részben fogjuk részletesebben megvizsgálni.

((("blokkok", "genezis blokk")))((("genezis blokk")))((("blokklánc (a)", "genezis blokk")))A teljes blokkláncot kezelő csomópontok a bitcoin blokklánc egy teljes és naprakész másolatát kezelik, melyben az összes tranzakció megtalálható. A blokkláncot egymástól függetlenül építik föl és ellenőrzik, az első blokktól (a genezis blokktól) kezdve, egészen a hálózatban ismert legutolsó blokkig bezárólag. Egy teljes blokkláncot kezelő csomópont önmaga képes hiteles módon bármelyik tranzakció ellenőrzésére, anélkül, hogy ehhez valamilyen másik csomópontot vagy információs forrást kellene igénybe vennie.A teljes csomópont a hálózatra támaszkodva kapja az új tranzakciós blokkokról az értesítéseket. Ezeket ellenőrzi, majd beépíti a saját, lokális blokkláncába.

((("bitcoin csomópontok", teljes csomópontok")))Teljes csomópont futtatásával érezhetjük igazán, milyen a bitcoin: az összes tranzakció függetlenül ellenőrizhető, és ehhez semmilyen más rendszerre sem kell támaszkodnunk, és semmilyen más rendszerben nem kell megbíznunk. Könnyű megmondani, hogy teljes csomópontot futtatunk-e, mert több, mint száz Gbájt háttértárra (diszk területre) van szükség a teljes blokklánc tárolásához. Ha a kliens sok diszk területet fogyaszt és 2-3 napra van szüksége, hogy „szinkronizálja” magát a hálózattal, akkor teljes csomópontot kezelő kliensről van szó. A központi szervezetektől való teljes függetlenségnek és szabadságnak ez az ára.

((("Satoshi kliens")))A teljes blokkláncot kezelő klienseknek van néhány alternatív megvalósítása, melyek a Bitcoin Core klienstől eltérő programozási nyelvet vagy szoftver architektúrát használnak. De a Bitcoin Core kliens, másképpen a Satoshi kliens referencia implementáció fordul elő a leggyakrabban. A bitcoin hálózat csomópontjainak több, mint 75%-a a Bitcoin Core különféle változatait futtatja. A +version+ üzenetben a „Satoshi” alverzió string azonosítja őket, a +getpeerinfo+ parancsban pedig pl. a +/Satoshi:0.8.6/+, amint azt korábban láttuk.

=== „Leltár” egyeztetés

((("bitcoin hálózat", "a blokklánc szinkronizálása")))Miután a csomópont hozzákapcsolódott a peerjeihez, elsőként egy teljes blokkláncot próbál létrehozni. Ha egy vadonatúj csomópontról van szó, amelynek egyáltalán nincs még blokklánca, akkor csak egyetlen blokkot ismer (a genezis blokkot) , amely statikusan be van ágyazva a kliens szoftverbe. A 0-ik blokktól, a genezis blokktól kezdve az új csomópontnak blokkot százezreit kell letöltenie ahhoz, hogy szinkronizálhassa magát a hálózattal és újraépíthesse a teljes blokkláncot.

((("blokklánc (a)", "blokklánc szinkronizálása")))((("szinkronizálás")))A „szinkronizálás” folyamata a +version+ üzenettel kezdődik, amely tartalmazza a +BestHeight+-et, a csomópont aktuális blokkláncának a magasságát (a blokkok számát). A csomópont a peerjeitől kapott +version+ üzenetből látja, hogy a peereknek hány blokkjuk van, és össze tudja hasonlítani azzal, hogy neki hány blokkja van a saját blokkláncán. A peer csomópontok egy +getblocks+ üzenetet váltanak egymással, amely tartalmazza a lokális blokkláncuk legfelső blokkjának hashét (ujjlenyomatát). A kapott hash az egyik peerben egy olyan blokkhoz fog tartozni, amely nem a legfelső blokk, hanem egy régebbi blokk, ebből a peer arra következtet, hogy a saját lokális blokklánca hosszabb, mint a többi peeré.

Az a peer, amelynek hosszabb a blokklánca, több blokkot tartalmaz, mint a többi csomópont, és meg tudja állapítani, hogy a többi csomópontnak mely blokkokra van szüksége ahhoz, hogy „felzárkózzanak”. Megállapítja, hogy melyik az első 500 megosztandó blokk, és egy +inv+ (inventory, leltár) üzenettel elküldi a blokkok hash értékeit. Az a csomópont, amelyben hiányoznak ezek a blokkok, úgy tudja beszerezni őket, hogy +getdata+ üzenetek sorozatát adja ki. Egy +getdata+ üzenet elkéri a teljes adatblokkot, és a kért blokkot az +inv+ üzenetből származó hash-sel azonosítja.

Tegyük fel például, hogy a csomópont csak a genezis blokkot tartalmazza. A peerjeitől egy +inv+ üzenetet fog kapni, amely lánc következő 500 blokkjának a hasheit tartalmazza. Megkezdi a vele kapcsolatban lévő peerektől a blokkok lekérését oly módon, hogy elosztja a terhelést, nehogy bármelyik peert túlterhelje a kéréseivel. Számon tartja, hogy minden egyes peer kapcsolatnál hány darab blokk van „úton”, vagyis hány darab blokk van, melyet lekért, de még nem kapott meg, és ellenőrzi, hogy a számuk nehogy egy határnál (+MAX_BLOCKS_IN_TRANSIT_PER_PEER+) nagyobb legyen. Ily módon ha a csomópontnak sok blokkra van szüksége, csak akkor kér újabbakat, ha az előző kérései már teljesültek, ami lehetővé teszi, hogy a peerek szabályozhassák a küldés ütemét és a hálózat ne terhelődjön túl. A blokkok megérkezésekor a csomópont hozzáadja a blokkokat a blokklánchoz, amint azt a  <<blockchain>> című fejezetben látni fogjuk. Amint a lokális blokklánc fokozatosan felépül, a csomópont további blokkokat kér és kap. A folyamat addig folytatódik, amíg a csomópont be nem éri a hálózat többi részét.

A lokális blokklánc és a peerek blokkláncainak összehasonlítása, valamint a hiányzó blokkok lekérése akkor megy végbe, ha egy csomópont egy időre offline állapotba került. Függetlenül attól, hogy a csomópont csak néhány percig volt offline, és csak pár blokkja hiányzik, vagy hónapokig, és néhány ezer blokkja hiányzik, a folyamat a +getbloks+ küldésével kezdődik, válaszként egy +inv+ érkezik, majd megtörténik a hiányzó blokkok letöltése. A <<inventory_synchronization>> a leltár és blokk terjedési protokollt mutatja.

[[inventory_synchronization]]
[role="smallerfifty"]
.Csomóponti blokklánc szinkronizálás egy peer blokkjainak letöltésével
image::images/mbc2_0806.png["InventorySynchronization"]

[[spv_nodes]]
=== Egyszerűsített fizetés ellenőrzést használó csomópontok (SPV csomópontok)

(("bitcoin hálózat", "SPV csomópontok", id="BNspvnodes08")))((("bitcoin csomópontok", "SPV csomópontok", id="BNospv08")))((("egyszerűsített fizetés ellenőrzés (SPV)", id="simple08")))Nem minden csomópont tudja a teljes blokkláncot tárolni. Sok bitcoin kliens olyan eszközökön fut, pl. okostelefonokon, tableteken vagy beágyazott rendszereken, amelyeknek a hely- és teljesítmény korlátai vannak. Az ilyen eszközök egyszerűsített fizetés ellenőrzési módszert (SPV) használnak, amely lehetővé teszi a teljes blokklánc tárolása nélküli működést. Ezeket a klienseket SPV klienseknek vagy pehelysúlyú klienseknek nevezzük. Ahogy a bitcoin egyre elterjedtebbé vált, az SPV csomópontok lettek a leggyakrabban előforduló bitcoin csomópontok, különösen a bitcoin pénztárcák esetén.

Az SPV csomópontok csak a blokkok blokkfejeit töltik le, az egyes blokkokba befoglalt tranzakciókat nem. Az így kapott, tranzakciók nélküli blokklánc 1000-szer kisebb a teljes blokkláncnál. Az SPV csomópontok nem tudnak teljes képet alkotni az összes elkölthető UTXO-ról, mivel nem tudnak a hálózatban lévő tranzakciókról. Az SPV csomópontok a tranzakciókat egy kicsit eltérő módon ellenőrzik, és ehhez olyan peereket használnak, melyek kívánság esetén a blokklánc releváns részeiről részleges képet szolgáltatnak.

Hasonlatképpen: a teljes csomópont olyan, mint egy idegen városban lévő turista, akinek részletes térképe van mindegyik utcáról és címről. Ezzel szemben az SPV csomópont olyan, mint egy idegen városban lévő turista, aki véletlenszerűen idegeneket kérdez meg, hogy merre kell mennie, és csak a főutcát ismeri. Mindkét turista ellenőrizni tudja egy utca meglétét, ha odamegy, de a térkép nélküli turista nem tudja, hogy mi van a mellékutcákban és nem tudja, hogy milyen egyéb utcák léteznek. Ha a térkép nélküli turista a Kossuth út 23-as szám előtt áll, nem tudhatja, hogy vannak-e a városban egyéb „Kossuth út 23” címek, és hogy ez a cím a helyes cím-e. A térkép nélküli turista akkor jár a legjobban, ha megkérdez sok embert, és reménykedik abban, hogy a többségük nem vágja át.

Az SPV a tranzakciókat a blokkláncokon belüli _mélységük_ alapján ellenőrzi, nem pedig a _magasságuk_ alapján. Míg egy teljes blokkláncot tartalmazó csomópont képes a blokkok és tranzakciók ezreiből álló, időben egészen a genezis blokkig visszanyúló, teljesen ellenőrzött láncok létrehozására, egy SPV csomópont csupán a blokkfejek láncát fogja ellenőrizni, de a tranzakciókét nem, és a blokkfejeket fogja kapcsolatba hozni a kérdéses tranzakcióval.

Például, ha a 300 000-ik blokkban lévő egyik tranzakcióról van szó, egy teljes csomópont a 300 000-ik blokktól egészen a genezis blokkig visszamenően elvégzi az elemzést, és az UTXO-król egy teljes adatbázist épít, vagyis az UTXO elköltetlenségének ellenőrzése révén állapítja meg, hogy a tranzakció érvényes-e vagy sem. Egy SPV csomópont ezzel szemben a tranzakció és az őt tartalmazó blokk közötti kapcsolatot egy _Merkle út_ használatával teremti meg (lásd <<merkle_trees>>). Ezután az SPV csomópont vár mindaddig, amíg a tranzakciót tartalmazó 300 000-ik blokk tetejére további hat blokk nem kerül, és a tranzakciót úgy ellenőrzi, hogy a 300 006 és 300 001 blokkok között megállapítja a tranzakció mélységét. Abból, hogy a hálózat többi csomópontja elfogadta a 300 000-ik blokkot, és azután a megfelelő munkavégzéssel további 6 blokkot hozott létre a 300 000-ik blokk tetején, implicit módon következik, hogy a tranzakció nem kettős költésből származik.

Egy SPV csomóponttal nem lehet elhitetni, hogy egy blokkban létezik egy tranzakció, ha az valójában nem létezik. Az SPV csomópont úgy ellenőrzi egy tranzakció meglétét, hogy lekéri a tranzakció Merkle útját, és ellenőrzi a blokkláncban lévő munkabizonyítékokat. De egy tranzakció „rejtve” is maradhat egy SPV csomópont számára. Egy SPV csomópont pontosan meg tudja állapítani, hogy létezik-e egy tranzakció, de azt nem tudja ellenőrizni, hogy nem létezik olyan tranzakció, amely ugyanezt az UTXO-t próbálja duplán elkölteni, mert nem rendelkezik az összes tranzakcióval. Az SPV csomópontok ellen ily módon DoS (denial of service, szolgáltatás megtagadási) támadás vagy kettős költési támadás indítható. Ahhoz, hogy ezt ki lehessen védeni, az SPV csomópontnak számos csomóponttal kell véletlenszerűen kapcsolatba lépnie, így növelni tudja annak a valószínűségét, hogy legalább egy becsületes csomópont van közöttük. Az SPV csomópontok emiatt sérülékenyek a hálózat szétszakadási támadásokkal vagy Sybil támadásokkal szemben, amelyeknél hamis csomópontokra vagy hamis hálózatokra kapcsolódnak, és nem tudják elérni a becsületes csomópontokat vagy a valódi bitcoin hálózatot.

Gyakorlati szempontból a hálózattal szoros kapcsolatban lévő SPV csomópontok elég biztonságosak, és jó kompromisszumot jelentenek az erőforrás felhasználás, a kényelem és a biztonság között. Azoknak, akiknek valóban fontos a biztonság, semmi sem pótolhatja egy teljes blokkláncból álló csomópont üzemeltetését.

[TIP]
====
A teljes blokkláncból álló csomópont úgy ellenőriz egy tranzakciót, hogy a tranzakció alatti blokkok ezreiből álló lánc vizsgálata révén megbizonyosodik róla, hogy az UTXO valóban elköltetlen, míg az SPV csomópont a blokk fölött lévő néhány blokk segítségével azt ellenőrzi, hogy milyen mélyen van eltemetve a blokk.
====

A blokkfejeket az SPV csomópontok a nem a +getblocks+, hanem a +getheaders+ üzenetekkel kérdezik le. Az a peer, amelyik válaszol, max. 2000 blokkfejet küld el egyetlen +headers+ üzenetben. A folyamat egyébként ugyanolyan, mint amit a teljes csomópontok használnak a teljes blokkok lekérésére. Az SPV csomópontok egy szűrőt is beállítanak a peerekkel létesített kapcsolataiknál, melyek kiszűrik a jövőbeli blokkokat és a peerek által küldött tranzakciókat. Az SPV csomópontok a számukra érdekes tranzakciókat a +getdata+ kéréssel kérdezik le. A peer válaszként egy +tx+ üzenetet hoz létre, amely a tranzakciót tartalmazza. Az <<spv_synchronization>> ábrán a blokkfejlécek szinkronizálása látható.

Mivel az SPV csomópontoknak külön le kell kérdezniük az egyes tranzakciókat ahhoz, hogy ellenőrizni tudják őket, ez veszélyeztetheti a titkosságot. A teljes blokkláncot tartalmazó csomópontokkal szemben (melyek a blokkokban lévő összes tranzakciót tartalmazzák), az SPV csomópontok egyedi adatlekérdezései akaratlanul is felfedhetik, hogy milyen bitcoin címek vannak a pénztárcáikban. Például egy harmadik fél által üzemeltetett megfigyelő hálózat nyilván tudja tartani az SPV pénztárca által kiadott összes kérést, és így kapcsolatba tudja hozni a kérésekben szereplő bitcoin címeket a felhasználó pénztárcájával, ami a privát szféra sérülésével jár.

[[spv_synchronization]]
.A blokkfejlécek szinkronizálása SPV csomópontok esetén
image::images/mbc2_0807.png["SPVSzinkronizálás"]

Az SPV/pehelysúlyú csomópontok bevezetése után nem sokkal, egyes bitcoin fejlesztők az ún. _Bloom szűrőkkel_ kívánták megoldani az SPV csomópontok által jelentett adatvédelmi kockázatot. A Bloom szűrők egy valószínűségi szűrőmechanizmus révén lehetővé teszik, hogy az SPV csomópontok csupán a tranzakciók egy részhalmazát fogadják, anélkül, hogy pontosan felfednék, mely címekre kíváncsiak.((("", startref="BNspvnodes08")))((("", startref="simple08")))

[[bloom_filters]]
=== Bloom szűrők

((("bitcoin hálózat", "Bloom szűrők", id="BNebloom08")))((("Bloom szűrők", id="bloom08")))((("adatvédelem, biztosítása", id="privacy08")))((("biztonság", "adatvédelem biztosítása", id="Sprivacy08")))A Bloom szűrő egy olyan, valószínűségi kereső szűrő, amellyel egy kívánt minta anélkül írható le, hogy pontosan megadnánk. A Bloom szűrőkkel hatékony módon lehet kifejezni a keresési mintákat, ugyanakkor biztosítható az adatvédelem. A Bloom szűrőket az SPV csomópontok arra használják, hogy a peerjeiktől egy adott mintának megfelelő tranzakciókat kérdezzenek le, de anélkül, hogy pontosan meg kellene adniuk, mely címek, kulcsok vagy tranzakciók érdeklik őket.

Az előző hasonlatunkban a térkép nélküli turista egy adott cím, pl a „Kossuth út 23” felől érdeklődik. Ha a járókelőktől azt kérdezi, hogy lehet eljutni erre a címre, akaratlanul is elárulja, hogy hová szeretne eljutni. A Bloom szűrő olyan, mint ha azt kérdezné, hogy „Vannak a közelben olyan utcák, melyek neve h-ra végződik?” Egy ilyen kérdés kevesebbet árul el arról, hogy hová szeretne menni, mint a „Kossuth út 23” utáni tudakozódás. Ezzel a módszerrel a turista részletesebben is meg tudja adni a címet, pl. „u-t-h-ra végződik”, vagy kevésbé részletesen, pl. „h-ra végződik”. A keresés pontosságának a szabályozása révén a turista több vagy kevesebb információt fed fel, de ennek az az ára, hogy több vagy kevesebb eredményhez jut. Ha egy kevésbé részletes minta után tudakozódik, akkor több lehetséges címet fog kapni és javul az adatvédelem, de az eredmények legtöbbje lényegtelen lesz a számára. Ha egy jobban rögzített minta után tudakozódik, akkor kevesebb eredményt fog kapni, de sérül az adatvédelem.

A Bloom szűrők úgy töltik be ezt a funkciójukat, hogy lehetővé teszik az SPV csomópontok számára, hogy az egyes tranzakcióknál megadott keresési minták a pontosság vagy az adatvédelem irányába mozduljanak el. Egy jobban specifikált Bloom szűrő pontos eredményeket ad, de azon az áron, hogy felfedi az SPV csomópont által keresett mintákat, és ezáltal a felhasználó pénztárcája által birtokolt címeket. Egy kevésbé pontos Bloom szűrő eredményként több tranzakciót fog visszaadni, melyek közül sok lényegtelen a csomópont számára, de a csomópont jobb adatvédelmet tud megvalósítani.

==== A Bloom szűrők működése

A Bloom szűrők megvalósítása N bites változó méretű tömbbel, és M db hash függvénnyel történik. A hash függvények olyanok, hogy a kimenetük mindig 1 és N között van, vagyis a kimenet a bitek tömbjének megfelelő. A hash függvényeket determinisztikus módon hozzák létre, ezért egy Bloom szűrőt megvalósító csomópont mindig ugyanazokat a hash függvényeket használja, és egy adott bemenet esetén mindig ugyanazt az eredményt adja. Különböző hosszúságú (N) Bloom szűrő és különböző számú (M) hash függvény választásával a Bloom szűrő különféle pontosságra állítható be, vagyis szabályozható az adatvédelem.

A lenti <<bloom1>> példában a Bloom szűrők működésének bemutatására egy 16 bites, nagyon kicsi tömböt és 3 hash függvényt használunk.

[[bloom1]]
.Egy egyszerű Bloom szűrő, egy 16 bites mezővel és 3 hash függvénnyel (3 hash függvény, hash függvény kimenetek 1-től 16-ig, üres Bloom szűrő, 16 bites tömb)
image::images/mbc2_0808.png["Bloom1"]

A Bloom szűrő úgy van inicializálva, hogy a tömb összes bitje nulla. Ha szeretnénk hozzáadni egy mintát a Bloom szűrőhöz, a mintát minden egyes hash függvénnyel össze hasheljük. Az első hash függvény a bemenetből egy 1 és N közötti számot állít elő. Az eredménynek megfelelő bitet a tömbben (melynek indexei 1 és N közöttiek) 1-be állítjuk, így rögzítve a hash függvény kimenetét. Ezután a következő hash függvénnyel beállítunk egy másik bitet, és így tovább. Az összes M db hash függvény alkalmazása után egy keresési minta áll elő a Bloom szűrőben, mivel M bitet +0+-ről +1+-be állítottunk.

<<bloom2>> példában a fenti egyszerű <<bloom1>> Bloom szűrőhöz az „A” keresési mintát adjuk hozzá:

Egy második minta hozzáadása egyszerűen a folyamat megismétlésével lehetséges. A mintát minden egyes hash függvénnyel egymás után össze-hasheljük, és az eredményeket a bitek +1+-be állításával rögzítjük. Ahogy a Bloom szűrőt egyre több mintával töltjük föl, valamelyik hash függvény eredménye egybeeshet egy már +1+-be állított bittel, ebben az esetben a bitet nem változtatjuk meg. Lényegében, ahogy egyre több mintát rögzítünk ugyanazokban a bitekben, a Bloom szűrő telítetté válik, mert egyre több bitje lesz +1+-be állítva, és a szűrő pontossága csökken. A szűrő emiatt tekinthető valószínűségi adatszerkezetnek – egyre több minta hozzáadásakor egyre kevésbé lesz pontos. A pontosság függ a hozzáadott minták számától, a bit tömb méretétől (N), illetve a hash függvények számától (M). Egy nagyobb bit tömbbel és több hash függvénnyel nagyobb pontossággal több minta rögzíthető. Egy kisebb bit tömbbel vagy kevesebb hash függvénnyel kevesebb minta rögzíthető, és kisebb pontosságot kapunk.

[[bloom2]]
.Az „A” keresési minta hozzáadása az egyszerű Bloom szűrőnkhöz
image::images/mbc2_0809.png["Bloom2"]

Az <<bloom3>> példában az egyszerű Bloom szűrőnkhöz egy második keresési mintát adunk, a „B”-t.

[[bloom3]]
[role="smallereighty"]
.Egy második keresési minta, a „B” hozzáadása az egyszerű Bloom szűrőnkhöz
image::images/mbc2_0810.png["Bloom3"]

Ha szeretnénk leellenőrizni, hogy egy minta benne van-e a Bloom szűrőben, akkor hasheljük össze minden egyes hash függvénnyel a mintát, és hasonlítsuk össze az így kapott bit mintát a bit tömbbel. Ha a hash függvények által indexelt összes bit +1+-ben van, akkor a mintát _valószínűleg_ tartalmazza a Bloom szűrő. Mivel a bitek a különféle minták átfedése miatt is beállításra kerülhetnek, a válasz nem biztos, inkább valószínű. Egyszerűen a Bloom szűrőnél a pozitív egyezés azt jelenti, hogy „talán igen”.

Alább <<bloom4>> példában azt ellenőrizzük, hogy az egyszerű Bloom szűrő tartalmazza-e az „X” mintát. A megfelelő bitek +1+-ben vannak, emiatt a minta valószínűleg egyezik:

[[bloom4]]
[role="smallereighty"]
.Az „X” minta meglétének ellenőrzése a Bloom szűrőben. Az eredmény pozitív egyezés, ami azt jelenti, hogy „talán”.
image::images/mbc2_0811.png["Bloom4"]

Ezzel szemben, ha ellenőrizünk egy mintát a Bloom szűrőben, és bármelyik ellenőrzött bit +0+, akkor ez azt mutatja, hogy a minta nem volt rögzítve a Bloom szűrőben. A negatív eredmény nem valószínűség, hanem bizonyosság. Egyszerűen szólva, a Bloom szűrőnél a negatív egyezés azt jelenti, hogy „biztosan nem”.

<<bloom5>> példában azt ellenőrizzük, hogy az „Y” minta létezik-e az egyszerű Bloom szűrőben. Az egyik szóban forgó bit +0+, emiatt a minta biztosan nem illeszkedik:

[[bloom5]]
.Az „Y” minta létezésének ellenőrzése a Bloom szűrőben. Az eredmény határozott negatív egyezés, ami azt jelenti, hogy „biztosan nem”
image::images/mbc2_0812.png[]

=== SPV csomópontok Bloom szűrő használata

Bloom szűrők segítségével kiszűrhetők azok a tranzakciók (és az azokat tartalmazó blokkok), amelyeket egy SPV csomópont fogad peerjeitől. Csak az SPV csomópontot érdeklő tranzakciók választhatók ki anélkül, hogy felfednénk, hogy az mely címekre vagy kulcsokra kíváncsi.

((("tranzakció-azonosítók (txid)")))Egy SPV csomópont "üresen" inicializálja a Bloom szűrőt. Ebben az állapotban a Bloom szűrő nem illeszkedik egyetlen mintára sem. Az SPV csomópont ezután összeállítja az összes címet, kulcsot és hasht, amely érdekli. Ezt a nyilvános kulcs hash, a szkript hash és a tranzakció-azonosítók kinyerésével készíti bármely UTXO-ról, amelyet pénztárcája kezel. Az SPV csomópont ezután hozzáadja ezeket a Bloom szűrőhöz úgy, hogy a Bloom szűrő akkor "illeszkedik", ha ezek a minták jelen vannak egy tranzakcióban, de magukat a mintákat nem fedi fel.

((("bitcoin csomópontok", "teljes csomópontok")))Az SPV csomópont ezután +filterload+ üzenetet küld a peernek, amely tartalmazza a kapcsolathoz használni kívánt Bloom szűrőt. A peer oldalon a Bloom szűrőket ellenőrzik minden bejövő tranzakcióval szemben. A teljes csomópont ellenőrzi a tranzakció különböző részeit a Bloom szűrővel, egyezést keresve, beleértve:

* A tranzakció azonosítója
* A tranzakciókimenetek zároló szkriptjeinek adatkomponensei (a szkript minden kulcsa és hashe)
* Az összes tranzakció bemenet
* Az összes bemeneti aláírás adatkomponensei (vagy tanú szkriptjei)

Mindezen komponensek figyelembevételével a Bloom szűrők felhasználhatók nyilvános kulcs hashekkel, szkriptekkel, +OP_RETURN+ értékekkel, aláírásokban szereplő nyilvános kulcsokkal, vagy akár okosszerződések és komplex szkriptek jövőbeni komponenseivel való illeszkedésre.

Miután létrejött a szűrő, a peer megvizsgálja az egyes tranzakciók kimeneteit a Bloom szűrővel szemben. Csak a szűrőre illeszkedő tranzakciókat küldi a csomópontnak.

A csomóponttól kapott +getdata+ üzenetre a peerek egy +merkleblock+ üzenettel válaszolnak, melyek minden egyes tranzakcióra vonatkozóan csak a szűrőre illeszkedő blokkok blokkfejeit tartalmazzák (lásd <<merkle_trees>>). A peerek ezt követően +tx+ üzeneteket is küldenek, melyek a szűrőre illeszkedő tranzakciókat tartalmazzák.

Mivel a teljes csomópont tranzakciókat küld az SPV csomópontnak, az SPV csomópont eldobja a hamis pozitív eredményeket, és a megfelelően illeszkedő tranzakciókat használja az UTXO készlet és a pénztárca egyenlegének frissítésére. Amikor frissíti a saját UTXO készlet nézetét, módosítja a Bloom szűrőt, hogy megfeleljen az esetleges jövőbeni tranzakcióknak, amelyek az éppen talált UTXO-ra hivatkoznak. A teljes csomópont ezután az új Bloom szűrőt használja az új tranzakciók illeszkedésének vizsgálatára, és a teljes folyamat megismétlődik.

A Bloom szűrőt beállító csomópont menet közben további mintákkal bővítheti a szűrőt, ehhez a+filteradd+ üzenetet kell elküldenie. Mivel a Bloom szűrőből nem lehet mintát eltávolítani, ezért ha valamelyik mintára már nincs szükség, akkor a csomópontnak először egy +filterclear+ üzenettel törölnie kell a Bloom szűrőt, majd egy újabb Bloom szűrőt kell küldenie.

Az SPV csomópontok hálózati protokollját és a Bloom szűrő mechanizmusát a http://bit.ly/1x6qCiO[BIP-37 (peer szolgáltatások)] definiálja.((("", startref="BNebloom08")))((("", startref="bloom08")))


=== SPV csomópontok és adatvédelem

Az SPV-t implementáló csomópontok gyengébb adatvédelmet élveznek, mint egy teljes csomópont. Egy teljes csomópont megkapja az összes tranzakciót, és ezért nem tár fel információt arról, hogy valamilyen címet használ-e a pénztárcájában. Az SPV csomópont a pénztárcájában lévő címekhez kapcsolódó tranzakciók szűrt listáját kapja. Ennek eredményeként csökkenti a tulajdonos adatvédelmét.

A Bloom szűrők az adatvédelmi veszteség csökkentésére szolgálnak. Nélkülük az SPV csomópontnak expliciten fel kellene sorolnia az összes őt érdeklő címet, és ez súlyosan megsértené az adatvédelmet. Azonban még Bloom szűrőkkel együtt is, egy SPV kliens forgalmát figyelő, vagy közvetlenül a P2P hálózathoz csomópontként csatlakoztatott ellenfél idővel elegendő információt gyűjthet ahhoz, hogy megtudja a címeket az SPV kliens pénztárcájában.

=== Titkosított és hitelesített kapcsolatok

((("bitcoin hálózat", "titkosított kapcsolatok")))((("titkosítás")))((("hitelesítés")))A bitcoin legtöbb új felhasználója azt feltételezi, hogy a bitcoin csomópont hálózati kommunikációja titkosítva van. Valójában a bitcoin eredeti megvalósítása titkosítás nélkül kommunikál. Noha ez nem jelent komoly problémát a teljes csomópontok adatvédelmi szempontjából, nagy problémát jelent az SPV csomópontok számára.

A bitcoin P2P hálózat adatvédelmének és biztonságának növelése érdekében kétféle megoldás biztosítja a kommunikáció titkosítását: a _Tor szállítás_ és a _P2P hitelesítés és titkosítás_ a BIP-150/151 segítségével.

==== Tor szállítás

((("Tor hálózat")))((("The Onion Routing network (Tor)")))A Tor, amely a _The Onion Routing network (A Hagyma Útválasztási hálózat)_ kifejezést jelöli, egy olyan szoftverprojekt és hálózat, amely adatok titkosítását és beágyazását kínálja véletlenszerűen kiválasztott hálózati útvonalak segítségével, amelyek anonimitást, nyomon követhetetlenséget és adatvédelmet kínálnak.

A Bitcoin Core számos konfigurációs lehetőséget kínál, amelyek lehetővé teszik bitcoin csomópont futtatását, a forgalom Tor hálózaton keresztül történő szállításával. Ezen felül a Bitcoin Core Tor rejtett szolgáltatást is kínálhat, amely lehetővé teszi más Tor csomópontok számára, hogy közvetlenül a Tor hálózaton keresztül csatlakozzanak a csomóponthoz.

A Bitcoin Core 0.12-es verziójától kezdve a csomópont automatikusan rejtett Tor szolgáltatást kínál, ha lehetséges kapcsolódni egy helyi Tor szolgáltatáshoz. Ha telepítette a Tort, és a Bitcoin Core folyamat olyan felhasználóként fut, amely rendelkezik a Tor hitelesítési süti hozzáféréséhez szükséges jogosultságokkal, akkor minden további nélkül működnie kell. A +debug+ opció használatával kapcsolja be a Bitcoin Core hibakeresését a Tor szolgáltatáshoz:

----
$ bitcoind --daemon --debug=tor
----

A naplókban a "tor: ADD_ONION successful" szöveget kell látnunk, jelezve, hogy a Bitcoin Core rejtett szolgáltatást adott hozzá a Tor hálózatához.

További információkat a Bitcoin Core Tor rejtett szolgáltatásként történő futtatásához a Bitcoin Core dokumentációjában (_docs/tor.md_), és különféle online oktatóanyagokban talál.

==== Peer-to-peer hitelesítés és titkosítás

((("Peer-to-Peer hitelesítés és titkosítás")))((("bitcoin továbbfejlesztési javaslatok", "Peer hitelesítés (BIP-150)")))((("bitcoin továbbfejlesztési javaslatok", "Peer-to-Peer Kommunikációs titkosítás (BIP-151)")))Két Bitcoin továbbfejlesztési javaslat, a BIP-150 és BIP-151, P2P hitelesítési és a titkosítási támogatást ad a bitcoin P2P hálózathoz. Ez a két BIP határozza meg az opcionális szolgáltatásokat, amelyeket a kompatibilis bitcoin csomópontok kínálhatnak. A BIP-151 lehetővé teszi az egyeztetett titkosítást a BIP-151-et támogató két csomópont közötti kommunikációban. A BIP-150 választható peer hitelesítést kínál, amely lehetővé teszi a csomópontok számára, hogy hitelesítsék egymás identitását ECDSA és titkos kulcsok használatával. A BIP-150 megköveteli, hogy a hitelesítés előtt a két csomópont titkosított kommunikációt hozzon létre a BIP-151 szerint.

2017 január óta a BIP-150 és a BIP-151 nem került implementálásra a Bitcoin Core-ban. A két javaslatot azonban legalább egy bcoin nevű alternatív bitcoin kliens implementálta.

A BIP-150 és a BIP-151 lehetővé teszik a felhasználók számára megbízható teljes csomóponthoz csatlakozó SPV kliensek futtatását, amelyek titkosítás és hitelesítés segítségével biztosítják az SPV kliens adatvédelmét.

Ezenkívül a hitelesítés felhasználható megbízható bitcoin csomópontok hálózatának létrehozására és a közbeékelődéses támadások megelőzésére. Végül, ha a P2P titkosítást széles körben alkalmazzák, akkor erősíteni fogja a bitcoin ellenállását a forgalomelemzéssel és az adatvédelemnek ártó megfigyeléssel szemben, különösen olyan totalitárius országokban, ahol az internethasználatot erősen ellenőrzik és figyelik.

((("", startref="BNospv08")))((("", startref="privacy08")))((("", startref="Sprivacy08")))A szabványt a https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki[BIP-150 (peer hitelesítés)] és a https://github.com/bitcoin/bips/blob/master/bip-0151.mediawiki[BIP-151 (peer-to-peer kommunikáció titkosítás)] definiálja.

=== Tranzakció poolok

((("bitcoin hálózat", "tranzakció poolok")))((("tranzakció poolok")))((("memory poolok (mempoolok)")))A megerősítetlen tranzakciókból a bitcoin hálózat majdnem minden csomópontja egy listát képez, az ún. _memory poolt_, _mempoolt_ vagy _tranzakció poolt_. A csomópontok ennek alapján követik nyomon azokat a tranzakciókat, melyeket a hálózat már ismer, de még nincsenek a blokkláncba foglalva. Például egy pénztárca csomópont a tranzakció poolt arra használja, hogy nyomon kövesse a hálózaton át a pénztárcába érkező, de még megerősítetlen befizetéseket.

Az tranzakciókat a csomópont a beérkezésük és ellenőrzésük után a tranzakció poolba helyezi, majd a hálózati szétterjedés érdekében a szomszédos csomópontoknak továbbítja.

((("elárvult tranzakciók poolja")))((("tranzakciók", "elárvult")))Némelyik implementációjában egy külön lista szolgál az elárvult tranzakciók nyilvántartására. Ha a tranzakció bemenetei olyan tranzakcióra hivatkoznak, amely még nem ismert, pl. hiányzik a szülő, akkor az elárvult tranzakció átmenetileg az elárvult tranzakciók pooljában tárolódik, amíg meg nem érkezik a szülő tranzakció.

Ha a tranzakció poolba bekerül egy tranzakció, akkor a csomópont ellenőrzi az elárvult tranzakciók között, hogy nem hivatkozik-e valamelyik árva tranzakció a most bekerült tranzakció valamelyik kimenetére (nem gyereke-e ennek a tranzakciónak), majd ellenőrzi az illeszkedő árva tranzakciókat. Ha a tranzakció érvényes, akkor eltávolítja az elárvult tranzakciók közül, és hozzáadja a tranzakciók pooljához, vagyis kiegészíti a szülő tranzakcióval elkezdett láncot. Az újonnan hozzáadott, már nem árva tranzakcióra vonatkozóan, a folyamatot rekurzív módon megismétli, és további leszármazottakat keres, amíg vannak további leszármazottak. Ennek a folyamatnak a révén egy szülő tranzakció beérkezése a tőle függő tranzakciók egész láncának rekonstruálását váltja ki, és az árva tranzakciókat ismét egyesíti a szüleikkel.

Sem a tranzakciók, sem az árva tranzakciók poolját (ha van ilyen) nem tárolják diszken, hanem csak a helyi memóriában léteznek, és dinamikusan, a bejövő hálózati üzenetek alapján kerülnek feltöltésre. Egy csomópont elindulásakor mindkét pool üres, és fokozatosan, az új tranzakciók beérkezésekor kerülnek feltöltésre.

A bitcoin kliens némelyik implementációja egy UTXO adatbázist vagy poolt is tartalmaz, amely a blokkláncban lévő elköltetlen kimenetek halmazának felel meg. Noha az „UTXO pool” hasonlónak tűnik a tranzakció poolhoz, de más adathalmazt jelent. A tranzakciók és az elárvult tranzakciók pooljával szemben az UTXO pool nem üresen indul, hanem elköltetlen tranzakció kimenetek millióit tartalmazza, mindent ami elköltetlen a genezis blokkig visszamenőleg. Az UTXO pool vagy a helyi tárban van, vagy a háttértár egy indexelt adatbázis táblája alkotja.

Míg a tranzakciók és árva tranzakciók pool-ja a helyi csomóponttól függ, és csomópontról csomópontra jelentősen változhat, attól függően, hogy a csomópont mikor indult vagy mikor indult újra, az UTXO pool a hálózatban kialakult konszenzusnak felel meg, és emiatt csak nagyon kicsiny eltérések lehetségesek az egyes csomópontok között. Ezen túlmenően a tranzakciók és árva tranzakciók pooljában csak megerősítetlen tranzakciók lehetnek, míg az UTXO pool csak megerősített kimeneteket tartalmazhat.