[[ch04_keys_addresses]]
== Keys, Addresses

((("cryptography", "defined")))((("cryptography", see="also keys and addresses")))คุณอาจเคยได้ยินว่า bitcoin คือการเข้ารหัสด้วยตัวเลขหรือคณิตศาสตร์  ในภาษากรีก Cryptography หรือ การเข้ารหัส หมายถึง "การเขียนข้อความลับ" แต่ศาสตร์ของการเข้ารหัสนั้นครอบคลุมมากกว่าการเขียนข้อความลับซึ่งเรียกว่าการเข้ารหัส การเข้ารหัสยังสามารถนำมาใช้เพื่อพิสูจน์ความลับโดยไม่เปิดเผยความลับ (digital signature) หรือสามารถพิสูจน์ความถูกต้องของข้อมูลได้ด้วย (digital fingerprint) ซึ่งเราสามารถพิสูจน์การเข้ารหัสนี้ได้โดยการใช้เครื่องมือที่ใช้กับ bitcoin อยู่ได้  เมื่ออ่านดูแล้วอาจรู้สึกได้ว่าการเข้ารหัสนั้นเป็นสิ่งจำเป็นแต่ส่วนสำคัญของ bitcoin นั้นกลับไม่ใช่การเข้ารหัส เนื่องจากข้อมูลการทำธุรกรรมต่างๆของ bitcoin ไม่ได้ทำการเข้ารหัสและไม่จำเป็นที่จะต้องเข้ารหัส ในบทความนี้เราจะแนะนำการเข้ารหัสที่ใช้ใน bitcoin ในรูปแบบของกุญแจ (Key), ที่อยู่ (address) และกระเป๋าสตางค์ (wallet)

=== Introduction

((("digital keys", see="keys and addresses")))((("keys and addresses", "overview of", id="KAover04")))((("digital signatures", "purpose of")))ผู้ที่มีกรรมสิทธิ์ใน bitcoin จะเป็นผู้ซึ่งถือ _digital keys_, _bitcoin addresses_ และ _digital signatures_ นั้นๆ   digital keys จะไม่ได้ถูกบันทึกไว้ในเครือข่าย แต่ถูกสร้างขึ้นและจัดเก็บเป็นไฟล์หรือฐานข้อมูลแบบง่ายๆที่เราสามารถเรียกว่า กระเป๋าสตางค์ หรือ _wallet_   digital keys ในกระเป๋าสตางค์ของผู้ใช้งานจะไม่เกี่ยวข้องกับโปรโตคอลของ bitcoin และสามารถสร้างและจัดการได้โดยผู้ใช้งานไม่จำเป็นต้องอ้างถึง blockchain หรืออินเทอร์เน็ต ทำให้กุญแจพวกนี้ช่วยสร้างให้คุณสมบัติของ bitcoin มีความน่าสนใจมากขึ้น รวมถึงความไว้วางใจ รูปแบบการรักษาความปลอดภัย การเข้ารหัสลับและการกระจายอำนาจ

การทำธุรกรรม bitcoin จำเป็นต้องมี digital signatures ที่ถูกต้องเพื่อนำมารวมไว้ใน blockchain ซึ่งมันถูกสร้างจาก secret key ของเราเท่านั้น ดังนั้นใครก็แล้วแต่ที่มีสำเนาของกุญแจ จะสามารถการควบคุม bitcoin ทั้งหมดที่มีในกุญแจนั้นได้ และผู้ที่นำกุญแจนี้มาทำการใช้จ่ายเปรียบเสมือน พยาน หรือ _witness_  ซึ่งข้อมูลของพยานในการทำธุรกรรมของ bitcoin เป็นการยืนยันถึงความเป็นเจ้าของ ของเงินที่แท้จริงที่ใช้ไป

((("public and private keys", "key pairs")))((("public and private keys", see="also keys and addresses")))Keys หรือ กุญแจนั้นจะประกอบกันเป็นคู่ด้วย กุญแจส่วนตัว (ซึ่งเป็นความลับ) และกุญแจสาธารณะ ลองคิดว่ากุญแจสาธารณะเหมือนกับหมายเลขบัญชีของธนาคาร ส่วนกุญแจส่วนตัวเหมือนกับ PIN ลับของเราหรือลายเซ็นบนเช็คที่ใช้ในการควบคุมบัญชี กุญแจดิจิทัลหรือกุญแจส่วนตัวนั้นไม่ค่อยพบเห็นโดยผู้ใช้งาน bitcoin เพราะส่วนใหญ่แล้วกุญแจจะถูกเก็บไว้ในไฟล์ของกระเป๋าสตางค์และจัดการโดยซอฟต์แวร์กระเป๋าสตางค์ของ bitcoin

ในส่วนของการชำระเงิน การทำธุรกรรมของ Bitcoin นั้นจะมีกุญแจสาธารณะของผู้รับที่แสดงด้วย digital fingerprint ที่เรียกว่า _bitcoin address_ ซึ่งใช้ในลักษณะเดียวกันกับชื่อผู้ที่รับเงินบนเช็ค (เช่น "ชำระเงินไปยัง")   ในกรณีส่วนมาก bitcoin address นั้นจะถูกสร้างขึ้นมาให้ตรงกับกุญแจสาธารณะ แต่อย่างไรก็ตามไม่ได้แปลว่า bitcoin address ทั้งหมดที่แสดงอยู่ จะเป็นกุญแจสาธารณะทั้งหมดเพราะมันยังสามารถสื่อถึงประโยชน์อื่นๆ เช่น สคริปต์ (คอมพิวเตอร์) ซึ่งเราจะได้เห็นตัวอย่างต่างๆจากบทความด้านล่าง ด้วยเหตุนี้ bitcoin address จึงเปรียบเสมือนนามธรรมในการรับเงินที่ทำให้การทำธุรกรรมปลายทางง่ายขึ้นคล้ายกับกระดาษเช็ค: เป็นการชำระเงินแบบหนึ่งที่สามารถจ่ายไปยังบัญชีผู้อื่น, จ่ายไปยังบัญชีบริษัท, จ่ายเป็นบิลหรือเงินจ่ายเป็นเงินสดได้    bitcoin address เป็นเพียงสิ่งเดียวที่ผู้ใช้งานจะเห็นเป็นประจำเนื่องจากมันเป็นส่วนที่พวกเขาต้องแชร์กับผู้ใช้งานบนโลก

ก่อนอื่นขอเริ่มต้นด้วยการเข้ารหัสและอธิบายหลักคณิตศาสตร์ที่ใช้ใน bitcoin ต่อไปเราจะไปยังวิธีการสร้างกุญแจ, การจัดเก็บและการจัดการ  หลังจากนั้นจะเข้าสู่วิธีการในการตรวจสอบรูปแบบการเข้ารหัสแบบต่างๆ ที่ใช้ในการทำกุญแจสาธารณะ, กุญแจส่วนตัว, addresses และสคริปต์   ท้ายสุดเป็นการนำกุญแจและ addresses ไปใช้ในรูปแบบที่ยากขึ้น: vanity (การสร้าง addresses ให้มีคำขึ้นต้นอย่างที่เราต้องการ), multisignature (การใช้กุญแจมากกว่า 1 กุญแจเพื่อยืนยันการทำธุรกรรม) และสคริปต์กับpaper wallets

==== Public Key Cryptography and Cryptocurrency

((("keys and addresses", "overview of", "public key cryptography")))((("digital currencies", "cryptocurrency")))การเข้ารหัสด้วย Public key ถูกคิดค้นขึ้นตั้งแต่ 1970 และถูกใช้เป็นรากฐานทางคณิตศาสตร์สำหรับระบบความปลอดภัยของคอมพิวเตอร์และข้อมูล

นับตั้งแต่การค้นพบเทคโนโลยีระบบรหัสแบบกุญแจสาธารณะโดยการใช้ฟังก์ชั่นทางคณิตศาสตร์ที่เหมาะสมหลายอย่างเช่นการแยกตัวประกอบด้วยจำนวนเฉพาะและการคูณเส้นโค้งทางคณิตศาสตร์ ซึ่งไม่สามารถย้อนกลับได้ ง่ายต่อการคำนวณในทิศทางเดียวและไม่สามารถคำนวณได้ในทิศทางตรงกันข้าม จากฟังก์ชันทางคณิตศาสตร์เหล่านี้การเข้ารหัสจะช่วยให้สามารถสร้าง digital secret และ digital signatures ที่ไม่อาจแก้ไขได้ Bitcoin ใช้การคูณเส้นโค้งเป็นพื้นฐานสำหรับการเข้ารหัส

ใน Bitcoin เราใช้เทคโนโลยีระบบรหัสแบบกุญแจสาธารณะเพื่อสร้างคู่คีย์ที่ควบคุมการเข้าถึง Bitcoin คู่กุญแจประกอบด้วยกุญแจส่วนตัวและกุญแจสาธารณะที่เกิดจากการนำกุญแจส่วนตัวมาทำเป็นกุญแจสาธารณะที่ไม่ซ้ำกัน กุญแจสาธารณะนั้นใช้เพื่อรับเงิน ส่วนกุญแจส่วนตัวจะใช้ในการยืนยันธุรกรรมเพื่อใช้จ่าย

There is a mathematical relationship between the public and the private key that allows the private key to be used to generate signatures on messages. These signatures can be validated against the public key without revealing the private key.

เมื่อทำการใช้ bitcoin เจ้าของ bitcoin คนปัจจุบันจะต้องทำการแสดง public key และ signature ของเธอ (ซึ่งจะแตกต่างกันไปในแต่ละครั้ง แต่ถูกสร้างมาจาก private key เดิม) ในธุรกรรมเพื่อที่จะใช้ bitcoin จำนวนนั้น และด้วยการแสดง public key และ signature นี้ ทำให้ทุกคนในเครือข่าย bitcoin สามารถตรวจสอบยืนยันและยอมรับว่าธุรกรรมนี้นั้นมีความสมบูรณ์ถูกต้อง เป็นการยืนยันว่า บุคคลที่กำลังจะทำการส่ง bitcoin จำนวนดังกล่าว เป็นเจ้าของ bitcoin จำนวนนั้นจริง ณ เวลาที่ทำธุรกรรม

[TIP]
====
((("keys and addresses", "overview of", "key pairs")))Wallet ส่วนมากจะทำการเก็บ private และ public keys ไว้ด้วยกันในลักษณะของ _key pair_ เพื่อความสะดวกสบายในการใช้งาน อย่างไรก็ตาม เนื่องจาก public key นั้น สามารถคำนวนได้จาก private key จึงทำให้มีความเป็นไปได้ที่ wallet จะเก็บบันทึกเพียงเฉพาะ private key เท่านั้นอีกด้วย
====

[[private_public_keys]]
==== Private และ Public Keys

((("keys and addresses", "overview of", "private and public key pairs")))((("elliptic curve cryptography")))((("cryptography", "elliptic curve cryptography")))Bitcoin wallet ทำหน้าที่เก็บชุดของ key pairs ซึ่งประกอบไปด้วย private key และ public key โดยที่ private key (k) นั้นเป็นตัวเลขที่มักเกิดจากการสุ่ม ซึ่งจาก private key เราจะใช้ฟังก์ชั่น elliptic curve multiplication ซึ่งเป็น one-way cryptographic function (ฟังก์ชั่นการเข้ารหัสทางเดียว) เพื่อสร้าง public key (K) และจาก public key (K) เราจะใช้ one-way cryptographic hash function (ฟังก์ชั่นการ hash ข้อมูลแบบทางเดียว) เพื่อสร้างเป็น bitcoin address (A) ในส่วนนี้ เราจะเริ่มต้นด้วยการสร้าง private key, ศึกษาคณิตศาสตร์ elliptic curve ที่ใช้ในการเปลี่ยน private key นั้นให้เป็น public key และสุดท้าย เราจะสร้าง bitcoin address ขึ้นมาจาก public key โดยความสัมพันธ์ระหว่าง private key, public key และ bitcoin address นั้นแสดงอยู่ใน <<k_to_K_to_A>>

[[k_to_K_to_A]]
.Private key, public key, และ bitcoin address
image::images/mbc2_0401.png["privk_to_pubK_to_addressA"]

.Why Use Asymmetric Cryptography (Public/Private Keys)?
****
asymmetric cryptography ทำไม asymmetric cryptography  ถึงถูกใช้ใน Bitcoin ที่จริงแล้ว Bitcoin ไม่ได้ใช้การ Encrypt (เพื่อทำให้ข้อมูลเป็นความลับ) กับธุรกรรม คุณสมบัติของ asymmetric cryptography ที่ Bitcoin ใช้คือความสามารถในการสร้าง _digital signatures_  (ลายเซ็นต์ดิจิทัล) ซึ่งก็คือ private key ที่เป็นเหมือนลายนิ้วมือในรูปแบบดิจิทัลที่ใช้ในการระบุตัวตนในธุรกรรมโดยมันเป็นลายเซ็นต์ที่เป็นลักษณะของชุดตัวเลข โดยลายเซ็นต์นี้จะถูกสร้างได้จากคนที่มี private key เท่านั้น อย่างไรก็ตามใครก็ตามนั้นสามารถเข้าถึง publi key และลายเซ็นต์ของธุรกรรมและสามารถใข้มันในการตรวจสอบความถูกต้องของลายเว็ฯต์ได้ คุณสมบัตินี่ของ asymmetric cryptography สามารถทำให้ใครก็ตามวสามารถตรวจสอบทุกๆลายเซ็นต์ในทุกๆธุรกรรมได้ โดยที่มีแต่เจ้าของ private key เท่านั้นที่สามารถสร้างลานยเซ็นต์ที่ถูกต้องได้
****

[[private_keys]]
==== Private Keys

((("keys and addresses", "overview of", "private key generation")))((("warnings and cautions", "private key protection"))) จริงๆแล้ว Private key เป็นแค่ตัวเลขธรรมดาเท่านั้นที่ถูกสุ่มขึ้นมาเท่านั้น โดยการเป็นเจ้าของและการควบคุม private key นั้นจะทำให้ผู้ใช้งานสามารถจัดการเงินทั้งหมดที่เกี่ยวเนื่องกับ bitcoin address นี้ได้ Private key นั้นจะถูกใช้ในการสร้างลายเซ็นดิจิทัลที่จะถูกใช้ในการใช้งาน bitcoin เพื่อเป็นการพิสูจน์ความเป็นเข้าของและเงินทุนในธุรกรรมนั้น private key นั้นจะต้องถูกเก็บเป็นความลับ เพราะถ้ามีใครก็ตามที่รู้ private key ของเรามันเท่ากับว่าเขามีสิทธิทั้งหมดในการ Bitcoin ที่อยู่ใน private key นั้น Private key นั้นควรถูกสำรองข้อมูลเอาไว้เพื่อป้องกันกรณีที่มันอาจจะหายได้เพราะถ้ามันหาย เงินนั้นก็จะหายไปตลอดกาลเช่นกัน 

[TIP]
====
Private key ของ bitcoin นั้นเป็นแค่ตัวเลข คุณสามารถสร้าง Private key ของคุณขึ้นมาแบบสุ่มโดยใช้แค่ เหรียญ,ดินสอและกระดาษ แค่คุณทอยเหรียญ 256 ครั้งคุณจะได้ชุดตัวเลขฐานสองแบบสุ่มที่เป็น private key ที่สามารถใช้ใน bitcoin wallet ได้ ส่วน Public key นั้นจะถูกสร้างจาก private key 
====

===== สร้าง private key จากเลขสุ่ม

ขั้นตอนที่สำคัญที่สุดอย่างแรกคือการคือการหาวิธีสุ่มเลขที่มีความปลอดภัย ในการสร้าง Bitcoin key นั้นจริงๆแล้วมันก็แค่การที่คุณเลือกเลขที่อยู่ระหว่าง 1-2^256 โดยคุณจะเลือกด้วยวิธีใดก็ได้ตราบใดที่มันไม่สามารถเดาหรือทำซ้ำได้ Software ของ Bitcon นั้นทำงานภายใต้การสุ่มเลขของระบบปฎิบัติการที่จะสุ่มตัวเลข 256 bit ขึ้นมา โดยทั่วไปแล้วระบบสุ่มเลขที่อยู่ในระบบปฏิบัตการนั้นถูกสร้างโดยมนุษย์ นั้นเป็นเหตุผลว่าทำไมซอฟต์แวร์ถึงขอให้คุณลากเมาส์ไปรอบๆหน้าจอซักพักหนึ่ง

นอกจากนี้ private key นั้นสามารถเป็นเลขอะไรก็ได้ที่อยู่ระหว่า +0+ และ +n-1 +โดยที่ค่า n เป็นค่าคงที่ ( n=1.1578 * 10^77 ซึ่งน้อยกว่า 2^256 นิดหน่อย) ที่ถูกกำหนดจาก eliptic curce ที่ใช้ใน bitcoin (ดู  <<elliptic_curve>> ) ในการสร้าง private key เราจะทำการสุ่มจากตัวเลข 256 bit และตรวจสอบว่ามันน้อยกว่าค่า n ในโปรแกรมมิ่งหรือเปล่า ซึ่งมันจะถูกสร้างจากการใส่ค่า String ที่มี Bit ขนาดใหญ่ที่ถูกสร้างจากการเข้ารหัสที่มีการสุ่มอย่างปลอดภัย จากการเข้ารหัสแบบ SHA256 ที่มันจะสร้างเลข 256 bit ถ้าตัวเลขที่ได้นั้นมีค่าน้อยกว่า n เราก็จะได้ private key ที่เหมาะสมมา แต่ถ้าไม่เราก็แค่ทำการสุ่มเลขอีกครั้ง

[WARNING]
====
((("random numbers", "random number generation")))((("entropy", "random number generation"))) อย่าเขียนคำสั่งในการสุ่มเลขด้วยตัวเองหรือใช้ฟังชั่นสุ่มเลข "พื้นฐาน" ของภาษาโปรแกรมมิ่ง แต่ใช้ใช้ cryptographically secure pseudorandom number generator (CSPRNG) ที่ม่าจากแหล่งที่เชื่อถือได้ การศึกษาคู่มือของ library ที่ใช้ในการสุ่มเลขที่คุณใช้จะทำให้คุณมั่นใจได้ว่ามันมีความปลอดภัย การเลือกใช้ CSPRNG ที่ถูกต้องนั้นมีผลมากต่อความปลอดภัยของ key 
====

Private Key ที่ถูกสร้างขึ้นมาโดยการสุ่มจะอยู่ในรูปของเลขฐาน 16 (256 bit จะอยู่ในรูปเลขฐาน 16 ที่มีจำนวน 64 หน่วย โดยแต่ละหน่วยมี 4 บิท)

----
1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
----


[TIP]
====
ขนาดของ bitcoin private key (2^256^) นั้นเป็นเลขจำนวนมหาศาล โดยประมาณแล้วมันมีขนาดอยู่ที่ 10^77^ ซึ่งถ้านำไปเปรียบเทียบแล้ว อะตอมที่สามารถคาดคะเนได้ในจักรวาลนั้นมีจำนวนอยู่ที่ 10^80^ 
====

((("dumpprivkey command"))) ในการสร้าง key จาก Bitcoin Core Client (see <<ch03_bitcoin_client>>), โดยการใช้คำสั่ง getnewaddress ด้วยเหตุผลด้านความปลอดภัยผลลัพท์ที่ได้จะมีแต่ Public key เท่านั้น Private key จะไม่ถูกแสดง ซึ่งสามารถใช้ bitcoind ในการแสดง private key ได้โดยใช้คำสั่ง dumpprivkey โดยคำสั่งนี้จะเป็นการแสดง Private key ที่อยู่ในรูปของ Base58 checksum-encoded หรือที่เรียกว่า _Wallet Import Format_ (WIF) โดยเราจะกล่าวถึงโดยละเอียดใน  <<priv_formats>> และนี่เป็นตัวอย่างในการสร้างและแสดง private key โดยใช้คำสั่งสองชุดดังต่อไปนี้

----
$ bitcoin-cli getnewaddress
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
$ bitcoin-cli dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
----

คำสั่ง dumpprivkey จะเป็นคำสั่งในการเปิด wallet และดึง private key ที่สร้างจากคำสั่ง getnewaddress มันเป็นไปไม่ได้เลยที่จะใช้ bitcoind ในการหา private key จาก public key ยกเว้นแต่มันจะเก็บไว้ใน wallet ทั้งหมด

[TIP]
=====================================================================
คำสั่ง dumpprivkey นั้นจะไม่ได้สร้าง private key จาก public key และมันเป็นไปไม่ได้เช่นกัน คำสั่งนี้จะเรียก private key ที่ wallet เข้าถึงได้รวมถึง private key ที่ถูกสร้างจากคำสั่ง getnewaddress
=====================================================================

[role="pagebreak-before"]
คุณสามารถใช้ชุดคำสั่งของ Bitcoin Explorer (see <<appdx_bx>>) ในการสร้างและแสดง private key ด้วยคำสั่ง +seed+, +ec-new+, และ +ec-to-wif+

----
$ bx seed | bx ec-new | bx ec-to-wif
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
----

[[pubkey]]
==== Public Keys

((("keys and addresses", "overview of", "public key calculation")))((("generator point"))) public key จะถูกคำนวณจาก private key โดยใช่  elliptic curve multiplication ซึ่งไม่สามารถคำนวนย้อนกลับได้ โดย _K_ = _k_ * _G_, โดย _k_ นั้นคือ private key ส่วน  _G_ จะเป็นค่าคงที่ ที่เรียกว่า _generator point_ และ _K_ คือ ผลลัพท์ของ public key ซึ่งววิธีย้อนกระบวนี้เป็นที่รู้จักในขื่อของ  "การหา discrete logarithm"  โดยการคำนวณหาค่า  _k_ โดยมี  __K__ เป็นค่าความยากในการหาค่าที่เป็นไปได้ทั้งหมดของ  _k_ จากการคำนวณแบบ  brute-force ก่อนที่เราจะพูดถึงการสร้าง public key จาก private key เราลองไปดูรายละเอียดเกี่ยวกับ elliptic curve cryptography  กัน

[TIP]
====
Elliptic curve multiplication นั้นเป็นฟังชั่นหนึ่งที่นักเข้ารหัสทั้งหลายเรียกมันว่า "trap door" มันง่ายมากที่จะคำนวณจากด้านเดียวแต่มันเป็นไปไม่ได้เลยที่จะคำนวณแบบย้อนกลับ เจ้าของ Private key นั้นสามารถสร้าง public key ได้อย่างง่ายดายและแบ่งปันมันให้โลกได้เห็น แต่ไม่มีใครเลยที่จะสามารถคำนวนหา private key จาก public key ได้ วิธีการทางคณิตศาสตร์นี้เป็นรากฐานของ digital signatures ที่ใช้ในการแสดงความเป็นเจ้าของใน bitcoin อีกด้วย
====

[[elliptic_curve]]
==== Elliptic Curve Cryptography 

((("keys and addresses", "overview of", "elliptic curve cryptography")))((("elliptic curve cryptography", id="eliptic04")))((("cryptography", "elliptic curve cryptography", id="Celliptic04"))) Elliptic curve cryptography นั้นเป็น asymmetric ประเภทหนึ่งหรือก็คือ public key cryptography ที่มีรากฐานจาก discrete logarithm problem โดยเป็นการเพิ่มจุดและลงบน elliptic curve

<<ecc-curve>> นี่คือตัวอย่างของ elliptic curve คล้ายกับที่ใช้ใน bitcoin

[[ecc-curve]]
[role="smallerthirty"]
elliptic curve
image::images/mbc2_0402.png["ecc-curve"]

Bitcoin นั้นใช้ elliptic curve แบบเฉพาะและค่าคงที่คณิตศาสตร์อีกชุดหนึ่ง เป็นมาตรฐานที่เรียกว่า +secp256k1+ ถูกสร้างจาก National Institute of Standards and Technology (NIST) โดย +secp256k1+ curve นั้นจะถูกสร้างจากฟังชั่นต่อไปนี้ 

[latexmath]
++++
\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}
++++

or

[latexmath]
++++
\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}
++++

ค่า _mod p_ (modulo prime number p) นั้นจะเป็นสิ่งที่กำหนด curve  บน finite field ของจำนวนเฉพาะ _p_ ซึ่งในรูปคณิตศาสตรจะอยู่ในรูปของ [\( \mathbb{F}_p \)],  โดย p = 2^256^ – 2^32^ – 2^9^ – 2^8^ – 2^7^ – 2^6^ – 2^4^ – 1 ซึ่งเป็นเลขที่มีจำนวนมาก

เพราะว่าเส้นโค้งนี้ถูกกำหนดจาก finite fiedls ของจำนวนเฉพาะแทนที่จะเป็นจำนวนจริง รูปแบบของ dots นั้นจะกระจายไปทั้งสองมิติ ซึ่งมันอาจจะนึกภาพตามยากซักหน่อย อย่างไรก็ตามสมการนั้นจะเหมือนกัน elliptic curve ที่ถูกสร้างจากจำนวนจริง จากตัวอย่าง <ecc-over-F17-math>elliptic curve จะมีขนาดที่เล็กกว่า finite fiedls ของจำนวนเฉพาะ 17 ซึ่ง dots จะอยู่ในรูปของ Grid ส่วน secp256k1 bitcoin elliptic curve นั้นจะมีรูปแบบของ dots ที่ซับซ้อนเป็น Grid ขนาดที่ใหญ่เกินกว่าที่เห็น

[[ecc-over-F17-math]]
[role="smallersixty"]
.Elliptic curve cryptography: ภาพของ elliptic curve โจากฟังชั่น F(p) โดย p=17
image::images/mbc2_0403.png["ecc-over-F17-math"]

และนี่เป็นตัวอย่างของจุด P บนพิกัด (x,y) ที่อยู่บนเส้นโค้ง secp256k1

----
P = (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424)
----

<<example_4_1>> วิธีการตรวจสอบด้วย Python

[[example_4_1]]
การใช้ Python ในการยืนยันว่าจุดนั้นอยู่บน elliptic curve
====
[source, pycon]
----
Python 3.4.0 (default, Mar 30 2014, 19:23:13)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
พิมพ์ "help", "copyright", "credits" หรือ "license" สำหรับข้อมูลเพิ่มเติม
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
>>> y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
>>> (x ** 3 + 7 - y**2) % p
0
----
====

ใน elliptic curve จะมีจุดที่เรียกว่า "point at infinity," ที่จะตรงกับค่า 0 ในคอมพิวเตอร์มันจะมีจุดที่ x=y=0 (ที่จะไม่อยู่บน elliptic curve แต่ก็เป็นกรณีที่สามารถตรวจสอบได้ง่ายๆ )

ถ้ามีการส่งเครื่องหมาย + เพิ่มเติม ที่มีคุณสมบัติคล้ายกับจำนวนจริงที่เคยเรียนสมัยเด็ก โดยถ้ามีสองจุดคือ P~1~ กับ P~2~ บน elliptic curve, และจุดที่สาม P~3~ = P~1~ + P~2~, ก็อยู่ elliptic curve

ในหลักเรขาคณิต จุดที่สาม P~3~ จะถูกคำนวนจากเส้นระหว่างจุด P~1~ และ P~2~ โดยเส้นจะตัดกับ elliptic curve ในจุด P~3~' = (x, y) ซึ่งจะเป็นสะท้อนกับในแกน x-axis เป็นจุด P~3~ = (x, –y).

จะมีกรณีพิเศษอยู่จำนวนหนึ่งที่สามารถอธิบายถึง "จุดที่จำนวนอนันต์ได้"

ถ้า P~1~ และ P~2~ เป็นจุดเดียวกัน เส้นระหว่าง  P~1~ และ P~2~  จะสัมผัสกับเส้นโค้งที่จุด P~1~ จุดสัมผัสที่ชิดกับเส้นโค้งนี้จะทำให้เกิดจุดใหม่ ซึ่งคุณสามารถใช้หลักทางแคลคูลัสในการคำนวณความชันของเส้นสัมผัสได้ หลักการนี้สามารถใช้ได้เสมอแม้ว่าพวกเราจะจำกัดจำนวนของจุดบนเส้นโค้งด้วยพิกัดสองจำนวน

In some cases (i.e., if P~1~ and P~2~ have the same x values but different y values), the tangent line will be exactly vertical, in which case P~3~ = "point at infinity."

ถ้า P~1~ คือ "จุดที่ไม่สิ้นสุด" แล้ว P~1~ + P~2~ = P~2~. มันก็คล้ายกับถ้า P~2~คือจุดที่ไม่สิ้นสุด แล้ว P~1~ + P~2~ = P~1~. นี่เป็นสิ่งที่บอกว่าจุดที่ไม่สิ้นสุดนั้นจะเป็นอย่างไรถ้าเป็น 0

มันกลายเป็นว่า pass:[+] นั้นมีความเกี่ยวข้องกันซึ่งหมายความว่า (A pass:[+] B) pass:[+] C = A pass:[+](B pass:[+] C) และนั้นหมาความว่าเราสามารถใช้ A pass:[+] B pass:[+] C โดยได้ไม่ต้องมีวงเล็บโดยมีความหมายเดียวกัน

Now that we have defined addition, we can define multiplication in the standard way that extends addition. For a point P on the elliptic curve, if k is a whole number, then kP = P + P + P + ... + P (k times). Note that k is sometimes confusingly called an "exponent" in this case.((("", startref="eliptic04")))((("", startref="Celliptic04")))

[[public_key_derivation]]
==== การสร้าง Public Key

((("keys and addresses", "overview of", "public key generation")))((("generator point")))Starting with a private key in the form of a randomly generated number _k_, we multiply it by a predetermined point on the curve called the _generator point_ _G_ to produce another point somewhere else on the curve, which is the corresponding public key _K_. The generator point is specified as part of the +secp256k1+ standard and is always the same for all keys in bitcoin:

[latexmath]
++++
\begin{equation}
{K = k * G}
\end{equation}
++++

where _k_ is the private key, _G_ is the generator point, and _K_ is the resulting public key, a point on the curve. Because the generator point is always the same for all bitcoin users, a private key _k_ multiplied with _G_ will always result in the same public key _K_. The relationship between _k_ and _K_ is fixed, but can only be calculated in one direction, from _k_ to _K_. That's why a bitcoin address (derived from _K_) can be shared with anyone and does not reveal the user's private key (_k_).

[TIP]
====
Private key นั้นสามารถแปลงเป็น public key ได้ แต่ public key นั้นไม่สามารถแปลงกลับมาเป็น Private key ได้เพราะมันเป็นการคำนวนแบบ one way
====

ในการสร้าง  elliptic curve multiplication เราจะนำ private key _k_ มาใช้ในการสร้างและคำนวนมันด้วยจุดกำเนิด G เพื่อหา public key _K_

----
K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G
----

Public key _K_ นั้นจะอยู่ที่จุด +K = (x,y)+:

----
K = (x, y)

ที่

x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

To visualize multiplication of a point with an integer, we will use the simpler elliptic curve over real numbers&#x2014;remember, the math is the same. Our goal is to find the multiple _kG_ of the generator point _G_, which is the same as adding _G_ to itself, _k_ times in a row. In elliptic curves, adding a point to itself is the equivalent of drawing a tangent line on the point and finding where it intersects the curve again, then reflecting that point on the x-axis.

<<ecc_illustrated>> shows the process for deriving _G_, _2G_, _4G_, as a geometric operation on the curve.

[TIP]
====
((("secp256k1 optimized C library")))Bitcoin uses the https://github.com/bitcoin-core/secp256k1[secp256k1 optimized C library] to do the elliptic curve math.((("", startref="KAover04")))
====

[[ecc_illustrated]]
.Elliptic curve cryptography: กราฟของจุด G ที่ถูกวีคุณด้วยค่าคงที่ k บน  elliptic curve
image::images/mbc2_0404.png["ecc_illustrated"]

=== Bitcoin Addresses

((("keys and addresses", "bitcoin addresses", id="KAaddress04"))) address ของ bitcoin นั้นจะเป็น String ที่ประกอบด้วยตัวเลขและตัวอักษรที่สามารถแผยแพร่แก่ใครก็ตามที่ต้องการจะส่งเงินให้คุณ Address นั้นถูกสร้างจาก Public key ที่ประกอบด้วยตัวเลขและตัวอักษร โดยขึ้นต้นด้วยเลข 1 และนี่คือตัวอย่าง address ของ bitcoin

----
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
----


โดยปกติแล้ว address ของ bitcoin จะอยู่ใน transaction ในส่วนของที่อยู่ของผู้รับเงิน ถ้าเราเปรียบเทียบ bitcoin กับเช็คเงินสด addresss ของ bitcoin ก็คือก็คือผู้รับ ที่เราจะต้องเขียยนชื่อผู้รับตามหลังประโยคที่บอกว่า "เงินจะถูกจ่ายให้กับ" บนเช็คเงินสดบางครั้งชื่อผู้รับก็อาจจะเป็นชื่อบัญชีธนาคารของผู้ถือ แต่ก็อาจมีข้อมูลเพิ่มเติมเช่น บริษัท องค์กร จำนวนเงิน เนื่องจากเช็คเงินสดนั้นไม่จำเป็นต้องใส่เลขบัญชีธนาคารแต่มักจะใส่เป็นชื่อผู้รับเงินเสียมากกว่า ซึ่งมันเป็นรูปแบบการจ่ายเงินที่ยืดหยุ่นมาก โดนธุรกรรมของ Bitcoin ก็มีลักษณะที่คล้ายกัน address ของ Bitcoin นั้นสามารถบ่งบอกถึงคู่ของ public/private key หรือสามารถเป็นอย่างอื่นก็ได้ เช่น payment script <<p2sh>> ในตอนนี้ลองมาดูตัวอย่างทั่วไปของ bitcoin address ที่ระบุถึงรูปแบบอื่นๆที่ไม่ใช่ public key กันก่อน

((("addresses", "algorithms used to create")) address ของ bitcoin นั้นถูกสร้างมาจาก public key ด้วยวิธี  one-way cryptographic hashing วิธีการ "hashing algorithm" หรือ "hash algorithm" เป็น one-way function ที่จะสร้างสิ่ง Hash หรือลายนิ้วมือจาก input ใดๆ  Cryptographic hash functions นั้นถูกใช้ในส่วนต่างๆของ bitcoin ไม่ว่าจะใน bitcoin addresses ใน script addresses และในการขุด Proof-of-Work โดยอักอริทึ่มที่ใช้คือ Secure Hash Algorithm (SHA) และ RACE Integrity Primitives Evaluation Message Digest (RIPEMD) โดยใช้ SHA256 และ RIPEMD160.

ถ้าเราเอา Public Key K มาตั้งต้นแล้วเราคำนวนมันด้วย SHA256 hash ตามด้วย RIPEMD160 hash ผลที่ได้นั้นจะเป็นตัวเลข 160-bit (20-byte)

[latexmath]
++++
\begin{equation}
{A = RIPEMD160(SHA256(K))}
\end{equation}
++++

ถ้า  _K_ คือ public key และ  _A_ คือ bitcoin address ที่เป็นผลลัพท์


[TIP]
====
bitcoin address นั้นไม่ใช่สิ่งเดียวกับ public key โดย Bitcoin assress นั้นจะถูกสร้างจาก public key โดยใช้ one-way function
====

Bitcoin address นั้นมักจะถูกเข้ารหัสด้วย "Base58Check" ที่ใช้ตัวอักษร 58 ตัวและ Checksum เพื่อให้มันอยู่ในรูปแบบที่มนุษย์สามารถอ่านได้ หลีกเลี่ยงความกำกวมและป้องกันความผิดพลาดที่อาจะเดินขึ้นได้ใน transcription และ entry ของ address โดย Base58Check นั้นยังถูกใช้ในอีกหลายส่วนของ Bitcoin ซึ่งเมื่อใดก็ตามที่ผู้ใช้งานต้องอ่านหรือคัดลอก bitcoin address รวมไปถึง private key,encrypt key และ script hash  มันจะถูกใช้เพื่อตรวจสอบความถูกต้อง 

[[pubkey_to_address]]
Public key to bitcoin address: การแปลง public key เป็น bitcoin address
image::images/mbc2_0405.png["pubkey_to_address"]

[[base58]]
==== Base58 และ Base58Check Encoding

((("keys and addresses", "bitcoin addresses", "Base58 and Base58check encoding")))((("Base58 and Base58check encoding", id="base5804")))((("addresses", "Base58 and Base58check encoding", id="Abase5804"))) ในการที่จะแสดงผลของตัวเลขที่มีความยาวมากๆในรูปแบบที่สามารถอ่านได้นั้นสามารถทำได้เพียงแค่ใช้ ตัวอักษรจำนวนหนึ่ง ในระบบคอมพิวเตอร์นั้นจะใช้ทั้งตัวเลขและตัวอักษรในการแสดงผลเลขฐานที่มากกว่า 10 ยกตัวอย่างเช่น ในระบบเลขฐาน 10 นั้นจะใช้เลข 0 ไปจนถึงเลข 9 สำหรับเลขฐาน 16 ระบบก็จะใช้ 16 ตัวอักษรโดยใช้ตัวอักษร A ถึง F เพิ่มเข้ามา โดยเลขฐาน 16 นั้นจะสามารถแสดงตัวเลขที่มีความยาวสั้นกว่าเมื่อเทียบกับเลขฐาน 10 โดย Base64 นั้นจะใช้ 26 อักษรตัวเล็ก 26 อักษรตัวใหญ่ ตัวเลข 10 ตัวและอีก 2 อักขระเข่น &#x201c;`+`&#x201d;  และ "/" ในการส่งข้อมูลเลขฐาน 2 ในรูปของข้อความอย่างอีเมล์ ใส่ส่วนของ Base58 นั้นเป็น subset ของ Base64 โดยใช้ตัวอักษรตัวเล็กและใหญ่รวมถึงตัวเลข แต่จะนำอักษรบางตัวที่ทำให้เกิดความผิดพลาดบ่อยๆออก เช่นอักษรที่มีความคล้ายคลึงกับตัวอักษรอื่นในฟอนด์อื่น โดยเฉพาะอย่างยิ่งใน Base58 นั้นจะคล้ายกับ Base64 ที่ตัวเลข 0 ตัว O ใหญ่ ตัว l เล็ก และตัว I ใหญ่ถึงอักขระอย่าง&#x201c;`+`&#x201d; และ "/"  หรือหมายถึงตัวอักษรตัวเล็กและใหญ่รวมถึงตัวเลขที่ไม่มี (0, O, l, I) เนื่องจาก <<base58alphabet>> มีตัวอักษร 58 ตัว

[[base58alphabet]]
.Bitcoin's Base58 alphabet
====
----
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
----
====


เพื่อเพิ่มความปลอดภัยในกรณีที่อาจจะมีการพิมพ์ผิดหรือถอดความผิด Base58Check คือรูปแบบการเข้ารหัสแบบ Base58 ที่มักถูกใช้ใน bitcoin ที่มีการใส่ไว้ในตัวโค้ด การตรวจสอบ checksum นี้จะเพิ่มข้อมูล 4 bytes ไว้หลังข้อมูลที่ถูกเข้ารหัส checksum นี้จะได้มาจาก hash ของข้อมูลที่ถูกเข้ารหัสที่จะถูกใช้ในการป้องกันการถอดความหรือการพิมพ์ที่ผิดพลาด ในโค้ดที่มี Base58Check การถอดรหัสโดยซอฟต์แวร์นั้นจะมีการคำนวน Checksum ของข้อมูลและเปรียบเทียบกับ Checksum ที่อยู่ในโค้ด ถ้าไม่เหมือนกัน โปรแกรมจะแจ้งเตือนว่าข้อมูลที่ถูกตรวจสอบด้วย Base58Check นั้นไม่ถูกต้อง สิ่งนี้จะสามารป้องกันการใส่ address ของ bitcoin ที่ผิดลงใน wallet ได้ว่ามันเป็นที่อยู่ปลายทางที่ผิด เพราะไม่อย่างนั้นเงินที่ส่งไปจะหายไปตลอดกาล

ในการเเปลงข้อมูล (ตัวเลข) ให้อยู่ในรูปแบบ Base58Check 

ต่อไปเราจำคำนวนค่า  "double-SHA" checksum ซึ่งหมายถึงเราจะใช้ SHA256 hash-algorithm มาคำนวนสองครั้งในค่าที่เราได้มา (Prefix และ Data)

----
checksum = SHA256(SHA256(prefix+data))
----

จากค่าที่เราได้จาก 32-byte hash (hash-of-a-hash) เราจะนำมาใช้แค่ 4 byte แรกโดย 4 byte นี้จะทำหน้าที่ error-checking code หรือ checksum โดยตัว checksum นี้จะถูกเติมลงในส่วนท้าย

ผลที่ได้นั้นจะจะประกอบด้วยสามส่วนนั่นคือ  prefix, data, checksum ซึ่งผลลัพท์นี้ได้จากการใช้  Base58 ที่กล่าวไปก่อนหน้านี้ <<base58check_encoding>> ที่อธิบายถึง กระบวนการ Base58Check encoding

[[base58check_encoding]]
Base58Check encoding คือ รูปแบบของ Base58 และ Checksum ที่ใช้ในการเข้ารหัสข้อมูลของ bitcoin
image::images/mbc2_0406.png["Base58CheckEncoding"]

ใน bitcoin ข้อมูลส่วนใหญ่จะแสดงให้ผู้ใช้งานเห็นอยู่ในรูป Base58Check ซึ่งทำมีขนาดกะทัดรัดและอ่านง่าย รวมถึงง่ายที่จะสังเกตุข้อผิดพลาด

[[base58check_versions]]
ตัวอย่าง Base58Check version prefix และผล encoded 
[options="header"]
|=======
|Type| Version prefix (hex)| Base58 result prefix
| Bitcoin Address | 0x00 | 1
| Pay-to-Script-Hash Address | 0x05 | 3
| Bitcoin Testnet Address | 0x6F | m or n
| Private Key WIF |  0x80 | 5, K, or L
| BIP-38 Encrypted Private Key | 0x0142 | 6P
| BIP-32 Extended Public Key | 0x0488B21E | xpub
|=======

==== Key Formats

((("keys and addresses", "bitcoin addresses", "key formats"))) Private key และ Public key นั้นจะเป็นตัวเลขที่สามารถอยู่ในรูปแบบที่หลากหลาย เพราะรูปแบบเหล่านั้นมีความหมายเดียวกันซึ่งมันก็คือเลขเดียวกัน ถึงแม้ว่ารูปแบบจะดูต่างกัน รูปแบบนั้นก็เป็นแค่สิ่งที่ทำให้มันอ่านง่ายขึ้นโดยไม่มีความผิดพลาดเกิดขึ้น

[[priv_formats]]
===== รูปแบบของ Private key

((("public and private keys", "private key formats")) private key นั้นสามารถอยู่ในรูปแบบต่างๆได้หลายรูปแบบ ซึ่งแต่ละแบบนั้นก็มีค่าเดียวกันกับตัวเลข 256 bit ในตาราง <<table_4-2>>  นั้นจะแสดงถึงรูปแบบสามแบบของที่ใช้ใน private key  ซึ่งแต่ละรูปแบบก็อาจใช้ในกรณีที่แตกต่างกัน Hexadecimal และ raw binary นั้นใช้ภายในตัวซอฟต์แวร์ที่ผู้ใช้งานจะไม่มีโอกาสได้เห็นนัก WIF ใช้ในกรณีที่จะ นำเข้าหรือส่งออก keys ระหว่าง wallets และมักถูกใช้ใน QRcode เพื่อแสดง private key

[[table_4-2]]
.Private key representations (encoding formats)
[options="header"]
|=======
|Type|Prefix|Description
| Raw | None | 32 bytes
| Hex | None | 64 hexadecimal digits
| WIF |  5 | Base58Check encoding: Base58 with version prefix of 128- and 32-bit checksum
| WIF-compressed | K or L | As above, with added suffix 0x01 before encoding
|=======

<<table_4-3>> private key ที่ถูกสร้างขึ้นในสามรูปแบบ

[[table_4-3]]
ตัวอย่าง key เดียวกันแต่รูปแบบต่างกัน
[options="header"]
|=======
|Format | Private key
| Hex | 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
| WIF | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
| WIF-compressed | KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
|=======

ทั้งหมดนี้แม้จะเป็นรูปแบบที่แตกต่างกันแต่ว่าเป็นตัวเลขเดียวกัน private key เดียวกันแม้จะดูแตกต่าง แต่รูปแบบหนึ่งนั้นสามารถแปลงเป็นรูปแบบอื่นๆได้อย่างง่ายดาน อย่าลืมว่า "raw binary" ไม่อยู่ใน <<table_4-3>> เพราะมันอยู่ในรูปแบบที่เข้ารหัสแล้ว เพราะฉะนั้นในรูปจึงไม่มี raw binary data  

เราสามารถใช้คำสั่ง +wif-to-ec+ ใน Bitcoin explorer (see <<appdx_bx>>) ในการดู WIF keys ของ private key นั้นได้

----
$ bx wif-to-ec 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd

$ bx wif-to-ec KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
----

=====  ถอดรหัสจาก Base58Check

คำสั่งของ Bitcoin Explorer นี้ (see <<appdx_bx>>) จะทำให้การเขียน shell script และ command line "pipes" ที่ใช้ในการจัดการกับ bitcoin keys ,address และ transaction นั้นง่ายขึ้น คุณสามารถใช้ Bitcoin Explorer ในการถอดรหัส  Base58Check บน command line ได้

เราใช้คำสั่ง base58check-decode ในการถอดรหัส Key ที่ยังไม่ถูกถอดรหัส

----
$ bx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
wrapper
{
    checksum 4286807748
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
    version 128
}
----

ผลลัพท์ที่ได้นั้นจะมี key ที่เป็น payload, WIF version prefix 128 และ checksum

สังเกตุว่า "payload" ของ key ที่ถูกบีบอัดแล้วจะถูกนำไปต่อท้ายกับ  suffix +01+ ซึ่งเป็นส่วนที่บอกว่า key นั้นถูกบีบอัดแล้ว

----
$ bx base58check-decode KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
wrapper
{
    checksum 2339607926
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01
    version 128
}
----

===== Encode from hex to Base58Check

ในการเข้ารหัส Base58Check (คำสั่งตรงข้ามกับคำสั่งที่ผ่านมา) เราจะใช้คำสั่ง +base58check-encode+ ของ Bitcoin Explorer (ดู<<appdx_bx>>)  และค่า hex ของ private key ในรูปแบบ WIF version prefix 128

----
bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd --version 128
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
----

===== Encode from hex (compressed key) to Base58Check

ในการเข้ารหัส Base58Check ในรูปแบบ private key ที่ถูกบีบอัดแล้ว  (see <<comp_priv>>) เราจะเติม suffix +01+ ต่อท้าย hex key และเข้ารหัสเป็นอย่างแรก

----
$ bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 --version 128
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
----

ผลที่ได้จาก WIF-compressed จะเริ่มต้นด้วย K ซึ่งเป็นการบอกว่า private key นี้มี suffix ของ 01 และจะถูกใช้ในการสร้าง public key ที่ถูกบีบอัด

===== Public key formats

((("public and private keys", "public key formats"))) Public key ก็สามารถแสดงอยู่ในรูปที่แตกต่างกันได้ โดยปกติจะอยู่ในรูปแบบที่บีบอัดและไม่ถูกบีบอัด

เราจะเห็นว่าที่ผ่านมา public key นั้นเป็นจุดบน elliptic curve ที่มีคู่ของ +(x,y)+ ที่มักจะอยู่ในรูป prefix +04+ ตามด้วยตัวเลข 256 bit สองตัว ซึ่งคือค่าในแกน x และค่าในแกน y prefix +04+ นั้นถูกใช้เพื่อให้เห็นความแตกต่างของ public key ที่ยังไม่ถูกบีบอัด โดย public key ที่ถูกบีบอัดแล้วจะขึ้นต้นด้วย +02+ ไม่ก็ +03+

นี่คือ public key ที่ถูกสร้างโดย private key ที่เราสร้างขึ้นมาก่อนหน้านี้ โดยอยู่ในรูปแกน x และ y

----
x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

นี่คือ public key เดียวกันที่อยู่ในรูปของตัวเลข 520 bit (เลขฐาน 16 130 ตัว) กับ prefix +04+ ตามด้วยค่า x และ y ใน +04 x y+ 

++++
<pre data-type="programlisting">
K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A&#x21b5;
07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
</pre>
++++

[[comp_pub]]
===== Compressed public keys

((("public and private keys", "compressed public keys"))) public key ที่ถูกบีบอัดแล้วนั้นได้ถูกนำไปใช้ใน bitcoin เพื่อลดขนาดของ transaction รวมถึงพื้นที่ที่ใช้ในการจัดเก็บของ Node ที่เก็บฐานข้อมูล Blockchain ของ Bitcoin ซึ่งธุรกรรมส่วนใหญ่จะประกอบด้วย public key ที่จำเป็นจะต้องถูกตรวจสอบด้วย credentials ของผู้ใช้งานรวมไปถึงการใช้ bitcoin โดย public key แต่ละชนิดจะมี  520 bits (prefix + x + y) ซึ่งเมื่อมันรวมเข้ากับธุรกรรมกว่าร้อยธุรกรรมที่มีใน Block หรือ 10000 ธุรกรรมต่อวัน มันก็เป็นข้อมูลจำนวนหนึ่งเลยทีเดียวที่จะถูกเพิ่มลงในฐานข้อมูล Blockchain 

อย่างที่เราเห็นใน Section <<pubkey>> public key นั้คือจุด (x,y) บน elliptic curve เนื่องจากเส้นโค้งนั้นเกิดจากฟังชั่นทางคณิตศาสตร์ จุดบนเส้นโค้งนั้นคือรูปแบบหนึ่งของสมการทางคณิตศาสตร์ และถ้าเรารู้ค่าในแกน x เราก็สามารถคำนวนหาค่าในแกน y ได้โดยการแก้สมการ y^2^ mod p = (x^3^ + 7) mod p ซึ่งมันสามารถทำให้เราสามารถเก็บแค่ค่า x บน public key ได้โดยไม่ต้องเก็บค่า Y เพื่อลดขนาดของ key และพื้นที่ที่ต้องใช้ในการเก็บให้เหลือเพียง 256 bits ทำให้สามารถประหยัดขนาดของธุรกรรมได้ถึง 50% และทำให้ประหยัดพื้นที่ที่ต้องใช้ในการเก็บข้อมูลอีกด้วย

Whereas uncompressed public keys have a prefix of +04+, compressed public keys start with either a +02+ or a +03+ prefix. Let's look at why there are two possible prefixes: because the left side of the equation is __y__^2^, the solution for _y_ is a square root, which can have a positive or negative value. Visually, this means that the resulting _y_ coordinate can be above or below the x-axis. As you can see from the graph of the elliptic curve in <<ecc-curve>>, the curve is symmetric, meaning it is reflected like a mirror by the x-axis. So, while we can omit the _y_ coordinate we have to store the _sign_ of _y_ (positive or negative); or in other words, we have to remember if it was above or below the x-axis because each of those options represents a different point and a different public key. When calculating the elliptic curve in binary arithmetic on the finite field of prime order p, the _y_ coordinate is either even or odd, which corresponds to the positive/negative sign as explained earlier. Therefore, to distinguish between the two possible values of _y_, we store a compressed public key with the prefix +02+ if the _y_ is even, and +03+ if it is odd, allowing the software to correctly deduce the _y_ coordinate from the _x_ coordinate and uncompress the public key to the full coordinates of the point. Public key compression is illustrated in <<pubkey_compression>>.

Here's the same public key generated previously, shown as a compressed public key stored in 264 bits (66 hex digits) with the prefix +03+ indicating the _y_ coordinate is odd:

----
K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
----

This compressed public key corresponds to the same private key, meaning it is generated from the same private key. However, it looks different from the uncompressed public key. More importantly, if we convert this compressed public key to a bitcoin address using the double-hash function (+RIPEMD160(SHA256(K))+) it will produce a _different_ bitcoin address. This can be confusing, because it means that a single private key can produce a public key expressed in two different formats (compressed and uncompressed) that produce two different bitcoin addresses. However, the private key is identical for both bitcoin addresses.

[[pubkey_compression]]
[role="smallerseventy"]
.Public key compression
image::images/mbc2_0407.png["pubkey_compression"]

Compressed public keys are gradually becoming the default across bitcoin clients, which is having a significant impact on reducing the size of transactions and therefore the blockchain. However, not all clients support compressed public keys yet. Newer clients that support compressed public keys have to account for transactions from older clients that do not support compressed public keys. This is especially important when a wallet application is importing private keys from another bitcoin wallet application, because the new wallet needs to scan the blockchain to find transactions corresponding to these imported keys. Which bitcoin addresses should the bitcoin wallet scan for? The bitcoin addresses produced by uncompressed public keys, or the bitcoin addresses produced by compressed public keys? Both are valid bitcoin addresses, and can be signed for by the private key, but they are different addresses!

To resolve this issue, when private keys are exported from a wallet, the WIF that is used to represent them is implemented differently in newer bitcoin wallets, to indicate that these private keys have been used to produce _compressed_ public keys and therefore _compressed_ bitcoin addresses. This allows the importing wallet to distinguish between private keys originating from older or newer wallets and search the blockchain for transactions with bitcoin addresses corresponding to the uncompressed, or the compressed, public keys, respectively. Let's look at how this works in more detail, in the next section.

[[comp_priv]]
===== Compressed private keys

((("public and private keys", "compressed private keys")))Ironically, the term "compressed private key" is a misnomer, because when a private key is exported as WIF-compressed it is actually one byte _longer_ than an "uncompressed" private key. That is because the private key has an added one-byte suffix (shown as 01 in hex in <<table_4-4>>), which signifies that the private key is from a newer wallet and should only be used to produce compressed public keys. Private keys are not themselves compressed and cannot be compressed. The term "compressed private key" really means "private key from which only compressed public keys should be derived," whereas "uncompressed private key" really means "private key from which only uncompressed public keys should be derived." You should only refer to the export format as "WIF-compressed" or "WIF" and not refer to the private key itself as "compressed" to avoid further confusion

<<table_4-4>> shows the same key, encoded in WIF and WIF-compressed formats.

[[table_4-4]]
ตัวอย่าง key เดียวกันแต่รูปแบบต่างกัน
[options="header"]
|=======
|Format | Private key
| Hex | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
| WIF | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
| Hex-compressed | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01
| WIF-compressed | KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
|=======

Notice that the hex-compressed private key format has one extra byte at the end (01 in hex). While the Base58 encoding version prefix is the same (0x80) for both WIF and WIF-compressed formats, the addition of one byte on the end of the number causes the first character of the Base58 encoding to change from a 5 to either a _K_ or _L_. Think of this as the Base58 equivalent of the decimal encoding difference between the number 100 and the number 99. While 100 is one digit longer than 99, it also has a prefix of 1 instead of a prefix of 9. As the length changes, it affects the prefix. In Base58, the prefix 5 changes to a _K_ or _L_ as the length of the number increases by one byte.

Remember, these formats are _not_ used interchangeably. In a newer wallet that implements compressed public keys, the private keys will only ever be exported as WIF-compressed (with a _K_ or _L_ prefix). If the wallet is an older implementation and does not use compressed public keys, the private keys will only ever be exported as WIF (with a 5 prefix). The goal here is to signal to the wallet importing these private keys whether it must search the blockchain for compressed or uncompressed public keys and addresses.

If a bitcoin wallet is able to implement compressed public keys, it will use those in all transactions. The private keys in the wallet will be used to derive the public key points on the curve, which will be compressed. The compressed public keys will be used to produce bitcoin addresses and those will be used in transactions. When exporting private keys from a new wallet that implements compressed public keys, the WIF is modified, with the addition of a one-byte suffix +01+ to the private key. The resulting Base58Check-encoded private key is called a "compressed WIF" and starts with the letter _K_ or _L_, instead of starting with "5" as is the case with WIF-encoded (noncompressed) keys from older wallets.


[TIP]
====
"Compressed private keys" is a misnomer! They are not compressed; rather, WIF-compressed signifies that the keys should only be used to derive compressed public keys and their corresponding bitcoin addresses. Ironically, a "WIF-compressed" encoded private key is one byte longer because it has the added +01+ suffix to distinguish it from an "uncompressed" one.((("", startref="KAaddress04")))
====

=== Implementing Keys and Addresses in Cpass:[++]

Let's look at the complete process of creating a bitcoin address, from a private key, to a public key (a point on the elliptic curve), to a double-hashed address, and finally, the Base58Check encoding. The C++ code in <<addr_example>> shows the complete step-by-step process, from private key to Base58Check-encoded bitcoin address. The code example uses the libbitcoin library introduced in <<alt_libraries>> for some helper functions.

[[addr_example]]
.Creating a Base58Check-encoded bitcoin address from a private key
====
[role="c_less_space"]
[source, cpp]
----
include::code/addr.cpp[]
----
====

The code uses a predefined private key to produce the same bitcoin address every time it is run, as shown in <<addr_example_run>>.((("", startref="base5804")))((("", startref="Abase5804")))

[[addr_example_run]]
.Compiling and running the addr code
====
[source,bash]
----
# Compile the addr.cpp code
$ g++ -o addr addr.cpp -std=c++11 $(pkg-config --cflags --libs libbitcoin)
# Run the addr executable
$ ./addr
Public key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa
Address: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK
----
====

[TIP]
====
The code in <<addr_example_run>> produces a bitcoin address (+1PRTT...+) from a _compressed_ public key (see <<comp_pub>>). If you used the uncompressed public key instead, it would produce a different bitcoin address (+14K1y...+).
====

=== Implementing Keys and Addresses in Python

((("keys and addresses", "implementing in Python", id="KApython04")))((("pybitcointools")))The most comprehensive bitcoin library in Python is https://github.com/vbuterin/pybitcointools[pybitcointools] by Vitalik Buterin. In <<key-to-address_script>>, we use the pybitcointools library (imported as "bitcoin") to generate and display keys and addresses in various formats.

[[key-to-address_script]]
.Key and address generation and formatting with the pybitcointools library
====
[source,python]
----
include::code/key-to-address-ecc-example.py[]
----
====

<<key-to-address_script_run>> shows  the output from running this code.

[[key-to-address_script_run]]
.Running key-to-address-ecc-example.py
====
++++
<pre data-type="programlisting">
$ python key-to-address-ecc-example.py
Private Key (hex) is:
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6
Private Key (เลขฐาน10) คือ
 26563230048437957592232553826663696440606756685920117476832299673293013768870
Private Key (WIF) คือ:
 5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K
Private Key ที่ถูกบีบอัดแล้ว (เลขฐาน16) คือ:
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601
Private Key (WIF ที่ถูกบีบอัด) is:
 KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S
Public Key ในค่าแกน(x,y)คือ:
 (41637322786646325214887832269588396900663353932545912953362782457239403430124L,
 16388935128781238405526710466724741593761085120864331449066658622400339362166L)
Public Key (เลขฐาน16) คือ:
 045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec&#x21b5;
243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176
 Public Key ที่ถูกบีบอัด (เลขฐาน16) คือ:
 025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec
Bitcoin Address (b58check) is:
 1thMirt546nngXqyPEz532S8fLwbozud8
Compressed Bitcoin Address (b58check) is:
 14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3
</pre>
++++
====


<<ec_math>> is another example, using the Python ECDSA library for the elliptic curve math and without using any specialized bitcoin libraries.

[[ec_math]]
.A script demonstrating elliptic curve math used for bitcoin keys
====
[source, python]
----
include::code/ec-math.py[]
----
====

<<ec_math_run>> shows the output produced by running this script.

[WARNING]
====
<<ec_math>> ((("random numbers", "os.urandom", see="entropy")))((("entropy", "os.urandom", see="random numbers")))((("random numbers", "random number generation")))((("entropy", "random number generation")))uses +os.urandom+, which reflects a cryptographically secure random number generator (CSRNG) provided by the underlying operating system. Caution: Depending on the OS, +os.urandom+ may _not_ be implemented with sufficient security or seeded properly and may _not_ be appropriate for generating production-quality bitcoin keys.((("", startref="KApython04")))
====

[[ec_math_run]]
.Installing the Python ECDSA library and running the ec_math.py script
====
----
$ # Install Python PIP package manager
$ sudo apt-get install python-pip
$ # Install the Python ECDSA library
$ sudo pip install ecdsa
$ # Run the script
$ python ec-math.py
Secret:  38090835015954358862481132628887443905906204995912378278060168703580660294000
EC point: (70048853531867179489857750497606966272382583471322935454624595540007269312627, 105262206478686743191060800263479589329920209527285803935736021686045542353380)
BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873
----
====

=== Advanced Keys and Addresses

((("keys and addresses", "advanced forms", id="KAadvanced04")))In the following sections we will look at advanced forms of keys and addresses, such as encrypted private keys, script and multisignature addresses, vanity addresses, and paper wallets.

[[p2sh_addresses]]
==== Pay-to-Script Hash (P2SH) and Multisig Addresses

((("keys and addresses", "advanced forms", "pay-to-script hash and multisig addresses")))((("Pay-to-Script-Hash (P2SH)", "multisig addresses and")))((("multisig addresses")))((("addresses", "multisig addresses")))As we know, traditional bitcoin addresses begin with the number “1” and are derived from the public key, which is derived from the private key.  Although anyone can send bitcoin to a “1” address, that bitcoin can only be spent by presenting the corresponding private key signature and public key hash.

((("bitcoin improvement proposals", "Pay to Script Hash (BIP-16)")))Bitcoin addresses that begin with the number “3” are pay-to-script hash (P2SH) addresses, sometimes erroneously called multisignature or multisig addresses. They designate the beneficiary of a bitcoin transaction as the hash of a script, instead of the owner of a public key. The feature was introduced in January 2012 with BIP-16 (see <<appdxbitcoinimpproposals>>), and is being widely adopted because it provides the opportunity to add functionality to the address itself. Unlike transactions that "send" funds to traditional “1” bitcoin addresses, also known as a pay-to-public-key-hash (P2PKH), funds sent to “3” addresses require something more than the presentation of one public key hash and one private key signature as proof of ownership. The requirements are designated at the time the address is created, within the script, and all inputs to this address will be encumbered with the same requirements.

A P2SH address is created from a transaction script, which defines who can spend a transaction output (for more details, see <<p2sh>>). Encoding a P2SH address involves using the same double-hash function as used during creation of a bitcoin address, only applied on the script instead of the public key:

----
script hash = RIPEMD160(SHA256(script))
----

The resulting "script hash" is encoded with Base58Check with a version prefix of 5, which results in an encoded address starting with a +3+. An example of a P2SH address is +3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM+, which can be derived using the Bitcoin Explorer commands +script-encode+, +sha256+, +ripemd160+, and +base58check-encode+ (see <<appdx_bx>>) as follows:

----
$ echo \
'DUP HASH160 [89abcdefabbaabbaabbaabbaabbaabbaabbaabba] EQUALVERIFY CHECKSIG' > script
$ bx script-encode < script | bx sha256 | bx ripemd160 \
| bx base58check-encode --version 5
3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM
----

[TIP]
====
P2SH is not necessarily the same as a multisignature standard transaction. A P2SH address _most often_ represents a multi-signature script, but it might also represent a script encoding other types of transactions.
====

===== Multisignature addresses and P2SH

Currently, the most common implementation of the P2SH function is the multi-signature address script. As the name implies, the underlying script requires more than one signature to prove ownership and therefore spend funds. The bitcoin multi-signature feature is designed to require M signatures (also known as the “threshold”) from a total of N keys, known as an M-of-N multisig, where M is equal to or less than N. For example, Bob the coffee shop owner from <<ch01_intro_what_is_bitcoin>> could use a multisignature address requiring 1-of-2 signatures from a key belonging to him and a key belonging to his spouse, ensuring either of them could sign to spend a transaction output locked to this address. This would be similar to a “joint account” as implemented in traditional banking where either spouse can spend with a single signature. Or Gopesh,((("use cases", "offshore contract services"))) the web designer paid by Bob to create a website, might have a 2-of-3 multisignature address for his business that ensures that no funds can be spent unless at least two of the business partners sign a transaction.

We will explore how to create transactions that spend funds from P2SH (and multi-signature) addresses in <<transactions>>.

==== Vanity Addresses

((("keys and addresses", "advanced forms", "vanity addresses")))((("vanity addresses", id="vanity04")))((("addresses", "vanity addresses", id="Avanity04")))Vanity addresses are valid bitcoin addresses that contain human-readable messages. For example, +1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33+ is a valid address that contains the letters forming the word "Love" as the first four Base-58 letters. Vanity addresses require generating and testing billions of candidate private keys, until a bitcoin address with the desired pattern is found. Although there are some optimizations in the vanity generation algorithm, the process essentially involves picking a private key at random, deriving the public key, deriving the bitcoin address, and checking to see if it matches the desired vanity pattern, repeating billions of times until a match is found.

Once a vanity address matching the desired pattern is found, the private key from which it was derived can be used by the owner to spend bitcoin in exactly the same way as any other address. Vanity addresses are no less or more secure than any other address. They depend on the same Elliptic Curve Cryptography (ECC) and SHA as any other address. You can no more easily find the private key of an address starting with a vanity pattern than you can any other address.

In <<ch01_intro_what_is_bitcoin>>, we introduced Eugenia, a children's charity director operating in the Philippines. Let's say that Eugenia is organizing a bitcoin fundraising drive and wants to use a vanity bitcoin address to publicize the fundraising. Eugenia will create a vanity address that starts with "1Kids" to promote the children's charity fundraiser. Let's see how this vanity address will be created and what it means for the security of Eugenia's charity.((("use cases", "charitable donations", startref="eugeniafour")))

===== Generating vanity addresses

It's important to realize that a bitcoin address is simply a number represented by symbols in the Base58 alphabet. The search for a pattern like "1Kids" can be seen as searching for an address in the range from +1Kids11111111111111111111111111111+ to +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz+. There are approximately 58^29^ (approximately 1.4 * 10^51^) addresses in that range, all starting with "1Kids." <<table_4-11>> shows the range of addresses that have the prefix 1Kids.

[[table_4-11]]
.The range of vanity addresses starting with "1Kids"
|=======
| *From* | +1Kids11111111111111111111111111111+
| | +1Kids11111111111111111111111111112+
| | +1Kids11111111111111111111111111113+
| | +...+
| *To* | +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz+
|=======

Let's look at the pattern "1Kids" as a number and see how frequently we might find this pattern in a bitcoin address (see <<table_4-12>>). An average desktop computer PC, without any specialized hardware, can search approximately 100,000 keys per second.

[[table_4-12]]
.The frequency of a vanity pattern (1KidsCharity) and average search time on a desktop PC
[options="header"]
|=======
| Length | Pattern | Frequency | Average search time
| 1 | 1K | 1 in 58 keys | < 1 milliseconds
| 2 | 1Ki| 1 in 3,364 | 50 milliseconds
| 3 | 1Kid | 1 in 195,000 | < 2 seconds
| 4 | 1Kids | 1 in 11 million | 1 minute
| 5 | 1KidsC | 1 in 656 million | 1 hour
| 6 | 1KidsCh | 1 in 38 billion | 2 days
| 7 | 1KidsCha | 1 in 2.2 trillion | 3–4 months
| 8 | 1KidsChar | 1 in 128 trillion | 13–18 years
| 9 | 1KidsChari | 1 in 7 quadrillion | 800 years
| 10 | 1KidsCharit | 1 in 400 quadrillion | 46,000 years
| 11 | 1KidsCharity | 1 in 23 quintillion | 2.5 million years
|=======


As you can see, Eugenia won't be creating the vanity address "1KidsCharity" anytime soon, even if she had access to several thousand computers. Each additional character increases the difficulty by a factor of 58. Patterns with more than seven characters are usually found by specialized hardware, such as custom-built desktops with multiple GPUs. These are often repurposed bitcoin mining "rigs" that are no longer profitable for bitcoin mining but can be used to find vanity addresses. Vanity searches on GPU systems are many orders of magnitude faster than on a general-purpose CPU.

Another way to find a vanity address is to outsource the work to a pool of vanity miners, such as the pool at http://vanitypool.appspot.com[Vanity Pool]. A pool is a service that allows those with GPU hardware to earn bitcoin searching for vanity addresses for others. For a small payment (0.01 bitcoin or approximately $5 at the time of this writing), Eugenia can outsource the search for a seven-character pattern vanity address and get results in a few hours instead of having to run a CPU search for months.

Generating a vanity address is a brute-force exercise: try a random key, check the resulting address to see if it matches the desired pattern, repeat until successful. <<vanity_miner_code>> shows an example of a "vanity miner," a program designed to find vanity addresses, written in C++. The example uses the libbitcoin library, which we introduced in <<alt_libraries>>.

[[vanity_miner_code]]
.Vanity address miner
====
[source,cpp]
----
include::code/vanity-miner.cpp[]
----
====

[NOTE]
====
<<vanity_miner_run>> uses +std::random_device+. Depending on the implementation it may reflect a CSRNG provided by the underlying operating system. In the case of a Unix-like operating system such as Linux, it draws from +/dev/urandom+. The random number generator used here is for demonstration purposes, and it is _not_ appropriate for generating production-quality bitcoin keys as it is not implemented with sufficient security.
====

The example code must be compiled using a pass:[C++] compiler and linked against the libbitcoin library (which must be first installed on that system). To run the example, run the ++vanity-miner++ executable with no parameters (see <<vanity_miner_run>>) and it will attempt to find a vanity address starting with "1kid."

[[vanity_miner_run]]
.Compiling and running the vanity-miner example
====
[source,bash]
----
$ # Compile the code with g++
$ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin)
$ # Run the example
$ ./vanity-miner
Found vanity address! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YT
Secret: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f
$ # Run it again for a different result
$ ./vanity-miner
Found vanity address! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFn
Secret: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623
# Use "time" to see how long it takes to find a result
$ time ./vanity-miner
Found vanity address! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXM
Secret: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349

real	0m8.868s
user	0m8.828s
sys	0m0.035s
----
====

The example code will take a few seconds to find a match for the three-character pattern "kid," as we can see when we use the +time+ Unix command to measure the execution time. Change the +search+ pattern in the source code and see how much longer it takes for four- or five-character patterns!

===== Vanity address security

((("security", "vanity addresses")))Vanity addresses can be used to enhance _and_ to defeat security measures; they are truly a double-edged sword. Used to improve security, a distinctive address makes it harder for adversaries to substitute their own address and fool your customers into paying them instead of you. Unfortunately, vanity addresses also make it possible for anyone to create an address that _resembles_ any random address, or even another vanity address, thereby fooling your customers.

Eugenia could advertise a randomly generated address (e.g., +1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy+) to which people can send their donations. Or, she could generate a vanity address that starts with 1Kids, to make it more distinctive.

In both cases, one of the risks of using a single fixed address (rather than a separate dynamic address per donor) is that a thief might be able to infiltrate your website and replace it with his own address, thereby diverting donations to himself. If you have advertised your donation address in a number of different places, your users may visually inspect the address before making a payment to ensure it is the same one they saw on your website, on your email, and on your flyer. In the case of a random address like +1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy+, the average user will perhaps inspect the first few characters "1J7mdg" and be satisfied that the address matches. Using a vanity address generator, someone with the intent to steal by substituting a similar-looking address can quickly generate addresses that match the first few characters, as shown in <<table_4-13>>.

[[table_4-13]]
.Generating vanity addresses to match a random address
|=======
| *Original Random Address* | 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
| *Vanity (4-character match)* | 1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy
| *Vanity (5-character match)* | 1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n
| *Vanity (6-character match)* | 1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX
|=======

So does a vanity address increase security? If Eugenia generates the vanity address +1Kids33q44erFfpeXrmDSz7zEqG2FesZEN+, users are likely to look at the vanity pattern word _and a few characters beyond_, for example noticing the "1Kids33" part of the address. That would force an attacker to generate a vanity address matching at least six characters (two more), expending an effort that is 3,364 times (58 &#x00D7; 58) higher than the effort Eugenia expended for her 4-character vanity. Essentially, the effort Eugenia expends (or pays a vanity pool for) "pushes" the attacker into having to produce a longer pattern vanity. If Eugenia pays a pool to generate an 8-character vanity address, the attacker would be pushed into the realm of 10 characters, which is infeasible on a personal computer and expensive even with a custom vanity-mining rig or vanity pool. What is affordable for Eugenia becomes unaffordable for the attacker, especially if the potential reward of fraud is not high enough to cover the cost of the vanity address generation.((("", startref="Avanity04")))((("", startref="vanity04")))((("", startref="eugeniafour")))

[[paper_wallets]]
==== Paper Wallets

((("keys and addresses", "advanced forms", "paper wallets")))((("paper wallets", id="paperw04")))((("wallets", "types of", "paper wallets", id="Wpaper04")))Paper wallets are bitcoin private keys printed on paper. Often the paper wallet also includes the corresponding bitcoin address for convenience, but this is not necessary because it can be derived from the private key. Paper wallets are a very effective way to create backups or offline bitcoin storage, also known as "cold storage." As a backup mechanism, a paper wallet can provide security against the loss of key due to a computer mishap such as a hard-drive failure, theft, or accidental deletion. As a "cold storage" mechanism, if the paper wallet keys are generated offline and never stored on a computer system, they are much more secure against hackers, keyloggers, and other online computer threats.

Paper wallets come in many shapes, sizes, and designs, but at a very basic level are just a key and an address printed on paper. <<table_4-14>> shows the simplest form of a paper wallet.

[[table_4-14]]
.Simplest form of a paper wallet—a printout of the bitcoin address and private key
[options="header"]
|=======================
|Public address|Private key (WIF)
|1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x|5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
|=======================


Paper wallets can be generated easily using a tool such as the client-side JavaScript generator at _bitaddress.org_. This page contains all the code necessary to generate keys and paper wallets, even while completely disconnected from the internet. To use it, save the HTML page on your local drive or on an external USB flash drive. Disconnect from the internet and open the file in a browser. Even better, boot your computer using a pristine operating system, such as a CD-ROM bootable Linux OS. Any keys generated with this tool while offline can be printed on a local printer over a USB cable (not wirelessly), thereby creating paper wallets whose keys exist only on the paper and have never been stored on any online system. Put these paper wallets in a fireproof safe and "send" bitcoin to their bitcoin address, to implement a simple yet highly effective "cold storage" solution. <<paper_wallet_simple>> shows a paper wallet generated from the bitaddress.org site.

[[paper_wallet_simple]]
.An example of a simple paper wallet from bitaddress.org
image::images/mbc2_0408.png[]

((("bitcoin improvement proposals", "Encrypted Private Keys (BIP-38)")))The disadvantage of a simple paper wallet system is that the printed keys are vulnerable to theft. A thief who is able to gain access to the paper can either steal it or photograph the keys and take control of the bitcoin locked with those keys. A more sophisticated paper wallet storage system uses BIP-38 encrypted private keys. The keys printed on the paper wallet are protected by a passphrase that the owner has memorized. Without the passphrase, the encrypted keys are useless. Yet, they still are superior to a passphrase-protected wallet because the keys have never been online and must be physically retrieved from a safe or other physically secured storage. <<paper_wallet_encrypted>> shows a paper wallet with an encrypted private key (BIP-38) created on the bitaddress.org site.

[[paper_wallet_encrypted]]
.ตัวอย่าง paper wallet จาก bitaddress.org ที่ผ่านการเข้ารหัสแล้ว โดยมี passphrase คือ "test"
image::images/mbc2_0409.png[]

[WARNING]
====
Although you can deposit funds into a paper wallet several times, you should withdraw all funds only once, spending everything. This is because in the process of unlocking and spending funds some wallets might generate a change address if you spend less than the whole amount. If the computer you use to sign the transaction is then compromised, you risk exposing the private key, giving access to the funds in the change address. By spending the entire balance of a paper wallet only once, you reduce the risk of key compromise. If you need only a small amount, send any remaining funds to a new paper wallet in the same transaction.
====

Paper wallets come in many designs and sizes, with many different features. Some are intended to be given as gifts and have seasonal themes, such as Christmas and New Year's themes. Others are designed for storage in a bank vault or safe with the private key hidden in some way, either with opaque scratch-off stickers, or folded and sealed with tamper-proof adhesive foil. Figures pass:[<a data-type="xref" href="#paper_wallet_bpw" data-xrefstyle="select: labelnumber">#paper_wallet_bpw</a>] through pass:[<a data-type="xref" href="#paper_wallet_spw" data-xrefstyle="select: labelnumber">#paper_wallet_spw</a>] show various examples of paper wallets with security and backup features.

[[paper_wallet_bpw]]
.ตัวอย่าง paper wallet จาก bitcoinpaperwallet.com ที่แสดง private key บนแถบพับ
image::images/mbc2_0410.png[]

[[paper_wallet_bpw_folded]]
.paper wallet จาก bitcoinpaperwallet.com ที่ปกปิด private key แล้ว
image::images/mbc2_0411.png[]

Other designs feature additional copies of the key and address, in the form of detachable stubs similar to ticket stubs, allowing you to store multiple copies to protect against fire, flood, or other natural disasters.((("", startref="KAadvanced04")))((("", startref="Wpaper04")))((("", startref="paperw04")))

[[paper_wallet_spw]]
.An example of a paper wallet with additional copies of the keys on a backup "stub"
image::images/mbc2_0412.png[]